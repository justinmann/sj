anon1(animations'stack list!#animation:, current'i32=)'stack anon1 {
  this
}

anon2()'stack anon2 {
  this
}

color(r'f32:, g'f32:, b'f32:, a'f32:)'stack color {
  this
}

gridlayout #element (children'stack array!#element:, margin'stack margin=, cols'stack array!gridunit=, rows'stack array!gridunit=, _rect'stack rect=)'heap gridlayout {
  this
}

hash![stack fontkey, weak font]()'stack hash![fontkey, font?] {
  --cdefine--
  #ifndef fontkey_weak_font_hash_typedef
  #define fontkey_weak_font_hash_typedef
  KHASH_INIT_TYPEDEF(fontkey_weak_font_hash_type, sjs_fontkey, sjs_font*)
  #endif
  --cdefine--
  --cfunction--
  #ifndef fontkey_weak_font_hash_function
  #define fontkey_weak_font_hash_function
  #if true
  KHASH_INIT_FUNCTION_DEREF(fontkey_weak_font_hash_type, sjs_fontkey, sjs_font*, 1, INVALID, INVALID)
  #else
  KHASH_INIT_FUNCTION(fontkey_weak_font_hash_type, sjs_fontkey, sjs_font*, 1, INVALID, INVALID)
  #endif
  #endif
  --cfunction--
  --c--
  _this->_hash = kh_init(fontkey_weak_font_hash_type);
  --c--
  this
}

hash![stack string, weak #element]()'stack hash![string, #element?] {
  --cdefine--
  #ifndef string_weak_iface_element_hash_typedef
  #define string_weak_iface_element_hash_typedef
  KHASH_INIT_TYPEDEF(string_weak_iface_element_hash_type, sjs_string, sji_element)
  #endif
  --cdefine--
  --cfunction--
  #ifndef string_weak_iface_element_hash_function
  #define string_weak_iface_element_hash_function
  #if true
  KHASH_INIT_FUNCTION_DEREF(string_weak_iface_element_hash_type, sjs_string, sji_element, 1, INVALID, INVALID)
  #else
  KHASH_INIT_FUNCTION(string_weak_iface_element_hash_type, sjs_string, sji_element, 1, INVALID, INVALID)
  #endif
  #endif
  --cfunction--
  --c--
  _this->_hash = kh_init(string_weak_iface_element_hash_type);
  --c--
  this
}

hash![stack string, weak #model]()'stack hash![string, #model?] {
  --cdefine--
  #ifndef string_weak_iface_model_hash_typedef
  #define string_weak_iface_model_hash_typedef
  KHASH_INIT_TYPEDEF(string_weak_iface_model_hash_type, sjs_string, sji_model)
  #endif
  --cdefine--
  --cfunction--
  #ifndef string_weak_iface_model_hash_function
  #define string_weak_iface_model_hash_function
  #if true
  KHASH_INIT_FUNCTION_DEREF(string_weak_iface_model_hash_type, sjs_string, sji_model, 1, INVALID, INVALID)
  #else
  KHASH_INIT_FUNCTION(string_weak_iface_model_hash_type, sjs_string, sji_model, 1, INVALID, INVALID)
  #endif
  #endif
  --cfunction--
  --c--
  _this->_hash = kh_init(string_weak_iface_model_hash_type);
  --c--
  this
}

list!stack rect(array'stack array!rect=)'stack list!rect {
  this
}

list!u32(array'stack array!u32=)'stack list!u32 {
  this
}

rect(x'i32:, y'i32:, w'i32:, h'i32:)'stack rect {
  this
}

runloop()'void {
  --c--
  #ifdef EMSCRIPTEN
  emscripten_set_main_loop((em_callback_func)sjf_mainloop, 0, 0);
  exit(0);
  #else
  bool quit = false;
  while (!quit) {
  sjf_mainloop();
  }
  #endif	
  --c--
}

scene2d(_size'stack size=, model'stack mat4=, view'stack mat4=, projection'stack mat4=, windowrect'stack rect=)'stack scene2d {
  this
}

shader(vertex'stack string:, pixel'stack string:)'stack shader {
  --c--
  _this->id = shader_load((char*)_this->vertex.data.data, (char*)_this->pixel.data.data);
  --c--
  this
}

string(count'i32=, data'stack array!char=)'stack string {
  this
}

windowrenderer()'stack windowrenderer {
  --c--
  if (SDL_Init(SDL_INIT_VIDEO) != 0) {
  halt("SDL_Init Error: %s\n", SDL_GetError());
  }
  #ifdef __APPLE__
  SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);
  SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 2);
  #else
  SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_ES);
  SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);
  SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 0);
  #endif
  SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);
  SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 24);
  _this->win = SDL_CreateWindow("Hello World!", 100, 100, 640, 480, SDL_WINDOW_OPENGL | SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);
  if (_this->win == 0) {
  halt("SDL_CreateWindow Error: %s\n", SDL_GetError());
  }
  SDL_GL_CreateContext((SDL_Window*)_this->win);
  #ifdef WIN32
  GLint GlewInitResult = glewInit();
  if (GLEW_OK != GlewInitResult) 
  {
  halt("ERROR: %s\n", glewGetErrorString(GlewInitResult));
  }
  #endif
  _this->ren = SDL_CreateRenderer((SDL_Window*)_this->win, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);
  if (_this->ren == 0) {
  halt("SDL_CreateRenderer Error: %s\n", SDL_GetError());
  }
  glClearColor( 0.0, 0.0, 0.0, 0.0 );
  glBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );
  glEnable( GL_BLEND );
  --c--
  this
}

global()'void {
  import  {
  }
  import  {
  }
  f32_pi'f32 : 3.14159265358979323846ff
  --cdefine--
  void halt(const char * format, ...);
  --cdefine--
  --cfunction--
  void halt(const char * format, ...) {
  va_list args;
  va_start(args, format);
  vprintf(format, args);
  va_end(args);
  #ifdef _DEBUG
  printf("\npress return to end\n");
  getchar();
  #endif
  exit(-1);
  }
  --cfunction--
  u32_maxvalue'u32 : (uint32_t)4294967295uu
  i32_maxvalue'i32 : -1i - 2147483647i
  i32_minvalue'i32 : 2147483647i
  emptystringdata'ptr = 0
  --c--
  sjv_emptystringdata = "";
  --c--
  --ctypedef--
  typedef struct td_delete_cb delete_cb;
  typedef struct td_delete_cb_list delete_cb_list;
  --ctypedef--
  --cstruct--
  struct td_delete_cb {
  void* _parent;
  void (*_cb)(void* _parent, void* object);
  };
  struct td_delete_cb_list {
  int size;
  delete_cb cb[5];
  delete_cb_list* next;
  };
  --cstruct--
  --cdefine--
  void ptr_hash(void* p, uint32_t* result);
  void ptr_isequal(void *p1, void* p2, bool* result);
  void delete_cb_list_free(delete_cb_list* d);
  void delete_cb_list_add(delete_cb_list* d, delete_cb cb);
  void delete_cb_list_remove(delete_cb_list* d, delete_cb cb);
  void delete_cb_list_invoke(delete_cb_list* d, void* p);
  void weakptr_init();
  void weakptr_release(void* v);
  void weakptr_cb_add(void* v, delete_cb cb);
  void weakptr_cb_remove(void* v, delete_cb cb);
  void weakptr_clear(void* parent, void* v);
  void ptr_init();
  void ptr_retain(void* ptr);
  bool ptr_release(void* ptr);
  --cdefine--
  --cfunction--
  void ptr_hash(void* p, uint32_t* result) {
  #ifdef __32__
  *result = kh_int_hash_func((uintptr_t)p);
  #else
  *result = kh_int64_hash_func((uintptr_t)p);
  #endif
  }
  void ptr_isequal(void *p1, void* p2, bool* result) {
  *result = (p1 == p2);
  }
  void delete_cb_list_free(delete_cb_list* d) {
  if (d->next) {
  delete_cb_list_free(d->next);
  }
  free(d);
  }
  void delete_cb_list_add(delete_cb_list* d, delete_cb cb) {
  if (d->size < 5) {
  d->cb[d->size] = cb;
  d->size++;
  }
  else {
  if (!d->next) {
  d->next = (delete_cb_list*)malloc(sizeof(delete_cb_list));
  }
  delete_cb_list_add(d->next, cb);
  }
  }
  void delete_cb_list_remove(delete_cb_list* d, delete_cb cb) {
  for (int i = 0; i < d->size; i++) {
  if (d->cb[i]._parent == cb._parent && d->cb[i]._cb == cb._cb) {
  for (int j = i; j < d->size - 1; j++) {
  d->cb[j] = d->cb[j + 1];
  }
  d->size--;
  }
  }
  if (d->next) {
  delete_cb_list_remove(d->next, cb);
  }
  }
  void delete_cb_list_invoke(delete_cb_list* d, void* p) {
  for (int i = 0; i < d->size; i++) {
  d->cb[i]._cb(d->cb[i]._parent, p);
  }
  if (d->next) {
  delete_cb_list_invoke(d->next, p);
  }
  }
  KHASH_INIT_TYPEDEF(weakptr_hashtable_type, void*, delete_cb_list)
  KHASH_INIT_FUNCTION(weakptr_hashtable_type, void*, delete_cb_list, 1, ptr_hash, ptr_isequal)
  khash_t(weakptr_hashtable_type)* weakptr_hashtable;
  void weakptr_init() {
  weakptr_hashtable = kh_init(weakptr_hashtable_type);
  }
  void weakptr_release(void* v) {
  khiter_t k = kh_get(weakptr_hashtable_type, weakptr_hashtable, v);
  if (k != kh_end(weakptr_hashtable)) {
  delete_cb_list* d = &kh_value(weakptr_hashtable, k);
  delete_cb_list_invoke(d, v);
  if (d->next) {
  delete_cb_list_free(d->next);
  }
  kh_del(weakptr_hashtable_type, weakptr_hashtable, k);
  }
  }
  void weakptr_cb_add(void* v, delete_cb cb) {
  delete_cb_list* d;
  khiter_t k = kh_get(weakptr_hashtable_type, weakptr_hashtable, v);
  if (k == kh_end(weakptr_hashtable)) {
  int ret;
  khiter_t k = kh_put(weakptr_hashtable_type, weakptr_hashtable, v, &ret);
  if (!ret) kh_del(weakptr_hashtable_type, weakptr_hashtable, k);
  d = &kh_value(weakptr_hashtable, k);
  d->size = 0;
  d->next = 0;
  }
  else {
  d = &kh_value(weakptr_hashtable, k);
  }
  delete_cb_list_add(d, cb);
  }
  void weakptr_cb_remove(void* v, delete_cb cb) {
  khiter_t k = kh_get(weakptr_hashtable_type, weakptr_hashtable, v);
  if (k != kh_end(weakptr_hashtable)) {
  delete_cb_list* d = &kh_value(weakptr_hashtable, k);
  delete_cb_list_remove(d, cb);
  }
  }
  KHASH_INIT_TYPEDEF(ptr_hashtable_type, void*, int)
  KHASH_INIT_FUNCTION(ptr_hashtable_type, void*, int, 1, ptr_hash, ptr_isequal)
  khash_t(ptr_hashtable_type)* ptr_hashtable;
  void ptr_init() {
  ptr_hashtable = kh_init(ptr_hashtable_type);
  }
  void ptr_retain(void* v) {
  khiter_t k = kh_get(ptr_hashtable_type, ptr_hashtable, v);
  if (k == kh_end(ptr_hashtable)) {
  int ret;
  khiter_t k = kh_put(ptr_hashtable_type, ptr_hashtable, v, &ret);
  if (!ret) kh_del(ptr_hashtable_type, ptr_hashtable, k);
  kh_value(ptr_hashtable, k) = 1;
  }
  else {
  kh_value(ptr_hashtable, k)++;
  }
  }
  bool ptr_release(void* v) {
  khiter_t k = kh_get(ptr_hashtable_type, ptr_hashtable, v);
  if (k != kh_end(ptr_hashtable)) {
  kh_value(ptr_hashtable, k)--;
  if (kh_value(ptr_hashtable, k) == 0) {
  kh_del(ptr_hashtable_type, ptr_hashtable, k);
  }
  return false;
  }
  return true;
  }
  void weakptr_clear(void* parent, void* v) {
  void** p = (void**)parent;
  if (*p != v) {
  halt("weakptr was changed without clearing callback");
  }
  *p = 0;
  }
  --cfunction--
  --c--
  ptr_init();
  weakptr_init();
  --c--
  --cinclude--
  #ifdef __GNUC__
  #if __x86_64__ 
  #define __LINUX__
  #define __64__
  #elif __i386__ 
  #define __LINUX__
  #define __32__
  #else
  Invalid bits
  #endif
  #elif _MSC_VER
  #if _WIN64 
  #define __WINDOWS__
  #define __64__
  #elif _WIN32 
  #define __WINDOWS__
  #define __32__
  #else
  Invalid bits
  #endif
  #else
  Invalid compiler
  #endif
  --cinclude--
  --cinclude--
  #ifdef WIN32
  #pragma warning(disable:4996)
  #define GLEW_STATIC
  #include <windows.h>
  #include <GL/glew.h>
  #include <GL/gl.h>
  #include <GL/glu.h>
  #endif
  --cinclude--
  rootwindowrenderer'stack windowrenderer : windowrenderer(this = windowrenderer())
  rootscene'stack scene2d : scene2d(this = scene2d(
    _size'stack size = _size,
    model'stack mat4 = model,
    view'stack mat4 = view,
    projection'stack mat4 = projection,
    windowrect'stack rect = windowrect
  ))
  modelsbyid'stack hash![string, #model?] : hash![stack string, weak #model](this = hash![stack string, weak #model]())
  elementsbyid'stack hash![string, #element?] : hash![stack string, weak #element](this = hash![stack string, weak #element]())
  animator'stack anon1 : anon1(this = anon1(
    animations'stack list!#animation : animations,
    current'i32 = current
  ))
  blurhorizontalshader'stack shader : shader(this = shader(
    vertex'stack string : vertex,
    pixel'stack string : pixel
  ))
  blurverticalshader'stack shader : shader(this = shader(
    vertex'stack string : vertex,
    pixel'stack string : pixel
  ))
  {
    fill'borderposition : 0
    left'borderposition : 1
    right'borderposition : 2
    top'borderposition : 3
    bottom'borderposition : 4
  }
  --cstruct--
  typedef struct {
  float x, y, z;    // position
  float r, g, b, a; // color
  } vertex3_color4_t;	
  --cstruct--
  {
    normal'buttonstate : 0
    hot'buttonstate : 1
    pressed'buttonstate : 2
  }
  import  {
    red'stack color : color(this = color(
      r'f32 : r,
      g'f32 : g,
      b'f32 : b,
      a'f32 : a
    ))
    green'stack color : color(this = color(
      r'f32 : r,
      g'f32 : g,
      b'f32 : b,
      a'f32 : a
    ))
    blue'stack color : color(this = color(
      r'f32 : r,
      g'f32 : g,
      b'f32 : b,
      a'f32 : a
    ))
    black'stack color : color(this = color(
      r'f32 : r,
      g'f32 : g,
      b'f32 : b,
      a'f32 : a
    ))
    white'stack color : color(this = color(
      r'f32 : r,
      g'f32 : g,
      b'f32 : b,
      a'f32 : a
    ))
    gray'stack color : color(this = color(
      r'f32 : r,
      g'f32 : g,
      b'f32 : b,
      a'f32 : a
    ))
  }
  --cdefine--
  double *
  make_distance_mapd( double *img,
  unsigned int width, unsigned int height );
  unsigned char *
  make_distance_mapb( unsigned char *img,
  unsigned int width, unsigned int height );    
  --cdefine--
  --cfunction--
  double *
  make_distance_mapd( double *data, unsigned int width, unsigned int height )
  {
  short * xdist = (short *)  malloc( width * height * sizeof(short) );
  short * ydist = (short *)  malloc( width * height * sizeof(short) );
  double * gx   = (double *) calloc( width * height, sizeof(double) );
  double * gy      = (double *) calloc( width * height, sizeof(double) );
  double * outside = (double *) calloc( width * height, sizeof(double) );
  double * inside  = (double *) calloc( width * height, sizeof(double) );
  double vmin = DBL_MAX;
  unsigned int i;
  // Compute outside = edtaa3(bitmap); % Transform background (0's)
  computegradient( data, width, height, gx, gy);
  edtaa3(data, gx, gy, width, height, xdist, ydist, outside);
  for( i=0; i<width*height; ++i)
  if( outside[i] < 0.0 )
  outside[i] = 0.0;
  // Compute inside = edtaa3(1-bitmap); % Transform foreground (1's)
  memset( gx, 0, sizeof(double)*width*height );
  memset( gy, 0, sizeof(double)*width*height );
  for( i=0; i<width*height; ++i)
  data[i] = 1 - data[i];
  computegradient( data, width, height, gx, gy );
  edtaa3( data, gx, gy, width, height, xdist, ydist, inside );
  for( i=0; i<width*height; ++i )
  if( inside[i] < 0 )
  inside[i] = 0.0;
  // distmap = outside - inside; % Bipolar distance field
  for( i=0; i<width*height; ++i)
  {
  outside[i] -= inside[i];
  if( outside[i] < vmin )
  vmin = outside[i];
  }
  vmin = fabs(vmin);
  for( i=0; i<width*height; ++i)
  {
  double v = outside[i];
  if     ( v < -vmin) outside[i] = -vmin;
  else if( v > +vmin) outside[i] = +vmin;
  data[i] = (outside[i]+vmin)/(2*vmin);
  }
  free( xdist );
  free( ydist );
  free( gx );
  free( gy );
  free( outside );
  free( inside );
  return data;
  }
  unsigned char *
  make_distance_mapb( unsigned char *img,
  unsigned int width, unsigned int height )
  {
  double * data    = (double *) calloc( width * height, sizeof(double) );
  unsigned char *out = (unsigned char *) malloc( width * height * sizeof(unsigned char) );
  unsigned int i;
  // find minimimum and maximum values
  double img_min = DBL_MAX;
  double img_max = DBL_MIN;
  for( i=0; i<width*height; ++i)
  {
  double v = img[i];
  data[i] = v;
  if (v > img_max)
  img_max = v;
  if (v < img_min)
  img_min = v;
  }
  // Map values from 0 - 255 to 0.0 - 1.0
  for( i=0; i<width*height; ++i)
  data[i] = (img[i]-img_min)/img_max;
  data = make_distance_mapd(data, width, height);
  // map values from 0.0 - 1.0 to 0 - 255
  for( i=0; i<width*height; ++i)
  out[i] = (unsigned char)(255*(1-data[i]));
  free( data );
  return out;
  }
  --cfunction--
  --cdefine--
  /*
  * Compute the local gradient at edge pixels using convolution filters.
  * The gradient is computed only at edge pixels. At other places in the
  * image, it is never used, and it's mostly zero anyway.
  */
  void computegradient(double *img, int w, int h, double *gx, double *gy);
  /*
  * A somewhat tricky function to approximate the distance to an edge in a
  * certain pixel, with consideration to either the local gradient (gx,gy)
  * or the direction to the pixel (dx,dy) and the pixel greyscale value a.
  * The latter alternative, using (dx,dy), is the metric used by edtaa2().
  * Using a local estimate of the edge gradient (gx,gy) yields much better
  * accuracy at and near edges, and reduces the error even at distant pixels
  * provided that the gradient direction is accurately estimated.
  */
  double edgedf(double gx, double gy, double a);
  double distaa3(double *img, double *gximg, double *gyimg, int w, int c, int xc, int yc, int xi, int yi);
  // Shorthand macro: add ubiquitous parameters dist, gx, gy, img and w and call distaa3()
  #define DISTAA(c,xc,yc,xi,yi) (distaa3(img, gx, gy, w, c, xc, yc, xi, yi))
  void edtaa3(double *img, double *gx, double *gy, int w, int h, short *distx, short *disty, double *dist);  
  --cdefine--
  --cfunction--
  /*
  * Compute the local gradient at edge pixels using convolution filters.
  * The gradient is computed only at edge pixels. At other places in the
  * image, it is never used, and it's mostly zero anyway.
  */
  void computegradient(double *img, int w, int h, double *gx, double *gy)
  {
  int i,j,k;
  double glength;
  #define SQRT2 1.4142136
  // Avoid edges where the kernels would spill over
  for(i = 1; i < h-1; i++) {
  for(j = 1; j < w-1; j++) {
  k = i*w + j;
  // Compute gradient for edge pixels only
  if((img[k]>0.0) && (img[k]<1.0)) {
  gx[k] = -img[k-w-1] - SQRT2*img[k-1] - img[k+w-1] + img[k-w+1] + SQRT2*img[k+1] + img[k+w+1];
  gy[k] = -img[k-w-1] - SQRT2*img[k-w] - img[k-w+1] + img[k+w-1] + SQRT2*img[k+w] + img[k+w+1];
  glength = gx[k]*gx[k] + gy[k]*gy[k];
  if(glength > 0.0) {
  // Avoid division by zero
  glength = sqrt(glength);
  gx[k]=gx[k]/glength;
  gy[k]=gy[k]/glength;
  }
  }
  }
  }
  // TODO: Compute reasonable values for gx, gy also around the image edges.
  // (These are zero now, which reduces the accuracy for a 1-pixel wide region
  // around the image edge.) 2x2 kernels would be suitable for this.
  }
  /*
  * A somewhat tricky function to approximate the distance to an edge in a
  * certain pixel, with consideration to either the local gradient (gx,gy)
  * or the direction to the pixel (dx,dy) and the pixel greyscale value a.
  * The latter alternative, using (dx,dy), is the metric used by edtaa2().
  * Using a local estimate of the edge gradient (gx,gy) yields much better
  * accuracy at and near edges, and reduces the error even at distant pixels
  * provided that the gradient direction is accurately estimated.
  */
  double edgedf(double gx, double gy, double a)
  {
  double df, glength, temp, a1;
  // Either A) gu or gv are zero, or B) both
  if ((gx == 0) || (gy == 0)) {
  // Linear approximation is A) correct or B) a fair guess
  df = 0.5-a;  
  } else {
  glength = sqrt(gx*gx + gy*gy);
  if(glength>0) {
  gx = gx/glength;
  gy = gy/glength;
  }
  /* Everything is symmetric wrt sign and transposition,
  * so move to first octant (gx>=0, gy>=0, gx>=gy) to
  * avoid handling all possible edge directions.
  */
  gx = fabs(gx);
  gy = fabs(gy);
  if(gx<gy) {
  temp = gx;
  gx = gy;
  gy = temp;
  }
  a1 = 0.5*gy/gx;
  if (a < a1) {
  // 0 <= a < a1
  df = 0.5*(gx + gy) - sqrt(2.0*gx*gy*a);
  } else if (a < (1.0-a1)) {
  // a1 <= a <= 1-a1
  df = (0.5-a)*gx;
  } else {
  // 1-a1 < a <= 1
  df = -0.5*(gx + gy) + sqrt(2.0*gx*gy*(1.0-a));
  }
  }
  return df;
  }
  double distaa3(double *img, double *gximg, double *gyimg, int w, int c, int xc, int yc, int xi, int yi)
  {
  double di, df, dx, dy, gx, gy, a;
  int closest;
  closest = c-xc-yc*w; // Index to the edge pixel pointed to from c
  a = img[closest];    // Grayscale value at the edge pixel
  gx = gximg[closest]; // X gradient component at the edge pixel
  gy = gyimg[closest]; // Y gradient component at the edge pixel
  if(a > 1.0) a = 1.0;
  if(a < 0.0) a = 0.0; // Clip grayscale values outside the range [0,1]
  if(a == 0.0) return 1000000.0; // Not an object pixel, return "very far" ("don't know yet")
  dx = (double)xi;
  dy = (double)yi;
  di = sqrt(dx*dx + dy*dy); // Length of integer vector, like a traditional EDT
  if(di==0) {
  // Use local gradient only at edges
  // Estimate based on local gradient only
  df = edgedf(gx, gy, a);
  } else {
  // Estimate gradient based on direction to edge (accurate for large di)
  df = edgedf(dx, dy, a);
  }
  return di + df; // Same metric as edtaa2, except at edges (where di=0)
  }
  // Shorthand macro: add ubiquitous parameters dist, gx, gy, img and w and call distaa3()
  #define DISTAA(c,xc,yc,xi,yi) (distaa3(img, gx, gy, w, c, xc, yc, xi, yi))
  void edtaa3(double *img, double *gx, double *gy, int w, int h, short *distx, short *disty, double *dist)
  {
  int x, y, i, c;
  int offset_u, offset_ur, offset_r, offset_rd,
  offset_d, offset_dl, offset_l, offset_lu;
  double olddist, newdist;
  int cdistx, cdisty, newdistx, newdisty;
  int changed;
  double epsilon = 1e-3;
  /* Initialize index offsets for the current image width */
  offset_u = -w;
  offset_ur = -w+1;
  offset_r = 1;
  offset_rd = w+1;
  offset_d = w;
  offset_dl = w-1;
  offset_l = -1;
  offset_lu = -w-1;
  /* Initialize the distance images */
  for(i=0; i<w*h; i++) {
  distx[i] = 0; // At first, all pixels point to
  disty[i] = 0; // themselves as the closest known.
  if(img[i] <= 0.0)
  {
  dist[i]= 1000000.0; // Big value, means "not set yet"
  }
  else if (img[i]<1.0) {
  dist[i] = edgedf(gx[i], gy[i], img[i]); // Gradient-assisted estimate
  }
  else {
  dist[i]= 0.0; // Inside the object
  }
  }
  /* Perform the transformation */
  do
  {
  changed = 0;
  /* Scan rows, except first row */
  for(y=1; y<h; y++)
  {
  /* move index to leftmost pixel of current row */
  i = y*w;
  /* scan right, propagate distances from above & left */
  /* Leftmost pixel is special, has no left neighbors */
  olddist = dist[i];
  if(olddist > 0) // If non-zero distance or not set yet
  {
  c = i + offset_u; // Index of candidate for testing
  cdistx = distx[c];
  cdisty = disty[c];
  newdistx = cdistx;
  newdisty = cdisty+1;
  newdist = DISTAA(c, cdistx, cdisty, newdistx, newdisty);
  if(newdist < olddist-epsilon)
  {
  distx[i]=newdistx;
  disty[i]=newdisty;
  dist[i]=newdist;
  olddist=newdist;
  changed = 1;
  }
  c = i+offset_ur;
  cdistx = distx[c];
  cdisty = disty[c];
  newdistx = cdistx-1;
  newdisty = cdisty+1;
  newdist = DISTAA(c, cdistx, cdisty, newdistx, newdisty);
  if(newdist < olddist-epsilon)
  {
  distx[i]=newdistx;
  disty[i]=newdisty;
  dist[i]=newdist;
  changed = 1;
  }
  }
  i++;
  /* Middle pixels have all neighbors */
  for(x=1; x<w-1; x++, i++)
  {
  olddist = dist[i];
  if(olddist <= 0) continue; // No need to update further
  c = i+offset_l;
  cdistx = distx[c];
  cdisty = disty[c];
  newdistx = cdistx+1;
  newdisty = cdisty;
  newdist = DISTAA(c, cdistx, cdisty, newdistx, newdisty);
  if(newdist < olddist-epsilon)
  {
  distx[i]=newdistx;
  disty[i]=newdisty;
  dist[i]=newdist;
  olddist=newdist;
  changed = 1;
  }
  c = i+offset_lu;
  cdistx = distx[c];
  cdisty = disty[c];
  newdistx = cdistx+1;
  newdisty = cdisty+1;
  newdist = DISTAA(c, cdistx, cdisty, newdistx, newdisty);
  if(newdist < olddist-epsilon)
  {
  distx[i]=newdistx;
  disty[i]=newdisty;
  dist[i]=newdist;
  olddist=newdist;
  changed = 1;
  }
  c = i+offset_u;
  cdistx = distx[c];
  cdisty = disty[c];
  newdistx = cdistx;
  newdisty = cdisty+1;
  newdist = DISTAA(c, cdistx, cdisty, newdistx, newdisty);
  if(newdist < olddist-epsilon)
  {
  distx[i]=newdistx;
  disty[i]=newdisty;
  dist[i]=newdist;
  olddist=newdist;
  changed = 1;
  }
  c = i+offset_ur;
  cdistx = distx[c];
  cdisty = disty[c];
  newdistx = cdistx-1;
  newdisty = cdisty+1;
  newdist = DISTAA(c, cdistx, cdisty, newdistx, newdisty);
  if(newdist < olddist-epsilon)
  {
  distx[i]=newdistx;
  disty[i]=newdisty;
  dist[i]=newdist;
  changed = 1;
  }
  }
  /* Rightmost pixel of row is special, has no right neighbors */
  olddist = dist[i];
  if(olddist > 0) // If not already zero distance
  {
  c = i+offset_l;
  cdistx = distx[c];
  cdisty = disty[c];
  newdistx = cdistx+1;
  newdisty = cdisty;
  newdist = DISTAA(c, cdistx, cdisty, newdistx, newdisty);
  if(newdist < olddist-epsilon)
  {
  distx[i]=newdistx;
  disty[i]=newdisty;
  dist[i]=newdist;
  olddist=newdist;
  changed = 1;
  }
  c = i+offset_lu;
  cdistx = distx[c];
  cdisty = disty[c];
  newdistx = cdistx+1;
  newdisty = cdisty+1;
  newdist = DISTAA(c, cdistx, cdisty, newdistx, newdisty);
  if(newdist < olddist-epsilon)
  {
  distx[i]=newdistx;
  disty[i]=newdisty;
  dist[i]=newdist;
  olddist=newdist;
  changed = 1;
  }
  c = i+offset_u;
  cdistx = distx[c];
  cdisty = disty[c];
  newdistx = cdistx;
  newdisty = cdisty+1;
  newdist = DISTAA(c, cdistx, cdisty, newdistx, newdisty);
  if(newdist < olddist-epsilon)
  {
  distx[i]=newdistx;
  disty[i]=newdisty;
  dist[i]=newdist;
  changed = 1;
  }
  }
  /* Move index to second rightmost pixel of current row. */
  /* Rightmost pixel is skipped, it has no right neighbor. */
  i = y*w + w-2;
  /* scan left, propagate distance from right */
  for(x=w-2; x>=0; x--, i--)
  {
  olddist = dist[i];
  if(olddist <= 0) continue; // Already zero distance
  c = i+offset_r;
  cdistx = distx[c];
  cdisty = disty[c];
  newdistx = cdistx-1;
  newdisty = cdisty;
  newdist = DISTAA(c, cdistx, cdisty, newdistx, newdisty);
  if(newdist < olddist-epsilon)
  {
  distx[i]=newdistx;
  disty[i]=newdisty;
  dist[i]=newdist;
  changed = 1;
  }
  }
  }
  /* Scan rows in reverse order, except last row */
  for(y=h-2; y>=0; y--)
  {
  /* move index to rightmost pixel of current row */
  i = y*w + w-1;
  /* Scan left, propagate distances from below & right */
  /* Rightmost pixel is special, has no right neighbors */
  olddist = dist[i];
  if(olddist > 0) // If not already zero distance
  {
  c = i+offset_d;
  cdistx = distx[c];
  cdisty = disty[c];
  newdistx = cdistx;
  newdisty = cdisty-1;
  newdist = DISTAA(c, cdistx, cdisty, newdistx, newdisty);
  if(newdist < olddist-epsilon)
  {
  distx[i]=newdistx;
  disty[i]=newdisty;
  dist[i]=newdist;
  olddist=newdist;
  changed = 1;
  }
  c = i+offset_dl;
  cdistx = distx[c];
  cdisty = disty[c];
  newdistx = cdistx+1;
  newdisty = cdisty-1;
  newdist = DISTAA(c, cdistx, cdisty, newdistx, newdisty);
  if(newdist < olddist-epsilon)
  {
  distx[i]=newdistx;
  disty[i]=newdisty;
  dist[i]=newdist;
  changed = 1;
  }
  }
  i--;
  /* Middle pixels have all neighbors */
  for(x=w-2; x>0; x--, i--)
  {
  olddist = dist[i];
  if(olddist <= 0) continue; // Already zero distance
  c = i+offset_r;
  cdistx = distx[c];
  cdisty = disty[c];
  newdistx = cdistx-1;
  newdisty = cdisty;
  newdist = DISTAA(c, cdistx, cdisty, newdistx, newdisty);
  if(newdist < olddist-epsilon)
  {
  distx[i]=newdistx;
  disty[i]=newdisty;
  dist[i]=newdist;
  olddist=newdist;
  changed = 1;
  }
  c = i+offset_rd;
  cdistx = distx[c];
  cdisty = disty[c];
  newdistx = cdistx-1;
  newdisty = cdisty-1;
  newdist = DISTAA(c, cdistx, cdisty, newdistx, newdisty);
  if(newdist < olddist-epsilon)
  {
  distx[i]=newdistx;
  disty[i]=newdisty;
  dist[i]=newdist;
  olddist=newdist;
  changed = 1;
  }
  c = i+offset_d;
  cdistx = distx[c];
  cdisty = disty[c];
  newdistx = cdistx;
  newdisty = cdisty-1;
  newdist = DISTAA(c, cdistx, cdisty, newdistx, newdisty);
  if(newdist < olddist-epsilon)
  {
  distx[i]=newdistx;
  disty[i]=newdisty;
  dist[i]=newdist;
  olddist=newdist;
  changed = 1;
  }
  c = i+offset_dl;
  cdistx = distx[c];
  cdisty = disty[c];
  newdistx = cdistx+1;
  newdisty = cdisty-1;
  newdist = DISTAA(c, cdistx, cdisty, newdistx, newdisty);
  if(newdist < olddist-epsilon)
  {
  distx[i]=newdistx;
  disty[i]=newdisty;
  dist[i]=newdist;
  changed = 1;
  }
  }
  /* Leftmost pixel is special, has no left neighbors */
  olddist = dist[i];
  if(olddist > 0) // If not already zero distance
  {
  c = i+offset_r;
  cdistx = distx[c];
  cdisty = disty[c];
  newdistx = cdistx-1;
  newdisty = cdisty;
  newdist = DISTAA(c, cdistx, cdisty, newdistx, newdisty);
  if(newdist < olddist-epsilon)
  {
  distx[i]=newdistx;
  disty[i]=newdisty;
  dist[i]=newdist;
  olddist=newdist;
  changed = 1;
  }
  c = i+offset_rd;
  cdistx = distx[c];
  cdisty = disty[c];
  newdistx = cdistx-1;
  newdisty = cdisty-1;
  newdist = DISTAA(c, cdistx, cdisty, newdistx, newdisty);
  if(newdist < olddist-epsilon)
  {
  distx[i]=newdistx;
  disty[i]=newdisty;
  dist[i]=newdist;
  olddist=newdist;
  changed = 1;
  }
  c = i+offset_d;
  cdistx = distx[c];
  cdisty = disty[c];
  newdistx = cdistx;
  newdisty = cdisty-1;
  newdist = DISTAA(c, cdistx, cdisty, newdistx, newdisty);
  if(newdist < olddist-epsilon)
  {
  distx[i]=newdistx;
  disty[i]=newdisty;
  dist[i]=newdist;
  changed = 1;
  }
  }
  /* Move index to second leftmost pixel of current row. */
  /* Leftmost pixel is skipped, it has no left neighbor. */
  i = y*w + 1;
  for(x=1; x<w; x++, i++)
  {
  /* scan right, propagate distance from left */
  olddist = dist[i];
  if(olddist <= 0) continue; // Already zero distance
  c = i+offset_l;
  cdistx = distx[c];
  cdisty = disty[c];
  newdistx = cdistx+1;
  newdisty = cdisty;
  newdist = DISTAA(c, cdistx, cdisty, newdistx, newdisty);
  if(newdist < olddist-epsilon)
  {
  distx[i]=newdistx;
  disty[i]=newdisty;
  dist[i]=newdist;
  changed = 1;
  }
  }
  }
  }
  while(changed); // Sweep until no more updates are made
  /* The transformation is completed. */
  }
  --cfunction--
  fadeshader'stack shader : shader(this = shader(
    vertex'stack string : vertex,
    pixel'stack string : pixel
  ))
  {
    topbottom'flowlayoutorientation : 0
    leftright'flowlayoutorientation : 1
    bottomtop'flowlayoutorientation : 2
    rightleft'flowlayoutorientation : 3
  }
  fonthash'stack hash![fontkey, font?] : hash![stack fontkey, weak font](this = hash![stack fontkey, weak font]())
  {
    gl_blend'glfeature : 0x0BE2
    gl_cull_face'glfeature : 0x0B44
    gl_depth_test'glfeature : 0x0B71
    gl_dither'glfeature : 0x0BD0
    gl_polygon_offset_fill'glfeature : 0x8037
    gl_sample_alpha_to_coverage'glfeature : 0x809E
    gl_sample_coverage'glfeature : 0x80A0
    gl_scissor_test'glfeature : 0x0C11
    gl_stencil_test'glfeature : 0x0B90
  }
  {
    gl_texture_2d'gltexture : 0x0DE1
    gl_texture_cube_map'gltexture : 0x8513
  }
  {
    gl_texture_min_filter'gltextureattribute : 0x2801
    gl_texture_mag_filter'gltextureattribute : 0x2800
    gl_texture_wrap_s'gltextureattribute : 0x2802
    gl_texture_wrap_t'gltextureattribute : 0x2803
  }
  {
    gl_clamp_to_edge'gltexturevalue : 0x812F
    gl_mirrored_repeat'gltexturevalue : 0x8370
    gl_repeat'gltexturevalue : 0x2901
    gl_nearest'gltexturevalue : 0x2600
    gl_linear'gltexturevalue : 0x2601
    gl_nearest_mipmap_nearest'gltexturevalue : 0x2700
    gl_linear_mipmap_nearest'gltexturevalue : 0x2701
    gl_nearest_mipmap_linear'gltexturevalue : 0x2702
    gl_linear_mipmap_linear'gltexturevalue : 0x2703
  }
  {
    gl_alpha'gltextureformat : 0x1906
    gl_luminance'gltextureformat : 0x1909
    gl_luminance_alpha'gltextureformat : 0x190A
    gl_rgb'gltextureformat : 0x1907
    gl_rgba'gltextureformat : 0x1908
  }
  {
    gl_unsigned_byte'gltexturetype : 0x1401
    gl_unsigned_short_5_6_5'gltexturetype : 0x8363
    gl_unsigned_short_4_4_4_4'gltexturetype : 0x8033
    gl_unsigned_short_5_5_5_1'gltexturetype : 0x8034
  }
  {
    gl_color_attachment0'glframebufferattachment : 0x8CE0
    gl_depth_attachment'glframebufferattachment : 0x8D00
    gl_stencil_attachment'glframebufferattachment : 0x8D20
  }
  {
    gl_texture_2d'glframebuffertexture : 0x0DE1
    gl_texture_cube_map_positive_x'glframebuffertexture : 0x8515
    gl_texture_cube_map_negative_x'glframebuffertexture : 0x8516
    gl_texture_cube_map_positive_y'glframebuffertexture : 0x8517
    gl_texture_cube_map_negative_y'glframebuffertexture : 0x8518
    gl_texture_cube_map_positive_z'glframebuffertexture : 0x8519
    gl_texture_cube_map_negative_z'glframebuffertexture : 0x851A
  }
  {
    gl_rgba4'glrenderbufferformat : 0x8056
    gl_rgb565'glrenderbufferformat : 0x8D62
    gl_rgb5_a1'glrenderbufferformat : 0x8057
    gl_depth_component16'glrenderbufferformat : 0x81A5
    gl_stencil_index8'glrenderbufferformat : 0x8D48
  }
  {
    gl_framebuffer_complete'glframebufferstatus : 0x8CD5
    gl_framebuffer_incomplete_attachment'glframebufferstatus : 0x8CD6
    gl_framebuffer_incomplete_missing_attachment'glframebufferstatus : 0x8CD7
    gl_framebuffer_unsupported'glframebufferstatus : 0x8CDD
  }
  glviewports'stack list!rect : list!stack rect(this = list!stack rect(
    array'stack array!rect = array
  ))
  glframebuffers'stack list!u32 : list!u32(this = list!u32(
    array'stack array!u32 = array
  ))
  --cdefine--
  void glid_retain(GLuint id);
  bool glid_release(GLuint id);
  void glid_gethash(GLuint id, uint32_t* result);
  void glid_isequal(GLuint id1, GLuint id2, bool* result);
  --cdefine--
  --cfunction--
  KHASH_INIT_TYPEDEF(glid_hash_type, GLuint, int)
  KHASH_INIT_FUNCTION(glid_hash_type, GLuint, int, 1, glid_gethash, glid_isequal)
  khash_t(glid_hash_type)* glid_hash;
  void glid_gethash(GLuint id, uint32_t* result) {
  *result = kh_int_hash_func(id);
  }
  void glid_isequal(GLuint id1, GLuint id2, bool* result) {
  *result = (id2 == id2);
  }
  void glid_init() {
  glid_hash = kh_init(glid_hash_type);
  }
  void glid_retain(GLuint id) {
  khiter_t k = kh_get(glid_hash_type, glid_hash, id);
  if (k == kh_end(glid_hash)) {
  int ret;
  khiter_t k = kh_put(glid_hash_type, glid_hash, id, &ret);
  if (!ret) kh_del(glid_hash_type, glid_hash, k);
  kh_value(glid_hash, k) = 1;
  }
  else {
  kh_value(glid_hash, k)++;
  }
  }
  bool glid_release(GLuint id) {
  khiter_t k = kh_get(glid_hash_type, glid_hash, id);
  if (k != kh_end(glid_hash)) {
  kh_value(glid_hash, k)--;
  if (kh_value(glid_hash, k) == 0) {
  kh_del(glid_hash_type, glid_hash, k);
  }
  return false;
  }
  return true;
  }
  --cfunction--
  --c--
  glid_init();
  --c--
  {
    fixed'gridunittype : 0
    star'gridunittype : 1
  }
  {
    fill'imagestretch : 0
    center'imagestretch : 1
    aspectratio'imagestretch : 2
  }
  --cstruct--
  typedef struct {
  float x, y, z;    // position
  float s, t;       // texture
  } vertex3_texture2_t;	
  --cstruct--
  {
    topbottom'listlayoutorientation : 0
    leftright'listlayoutorientation : 1
    bottomtop'listlayoutorientation : 2
    rightleft'listlayoutorientation : 3
  }
  looplastrect'stack rect = rect(this = rect(
    x'i32 : x,
    y'i32 : y,
    w'i32 : w,
    h'i32 : h
  ))
  mouse_captureelement'heap #element? = empty'heap #element?
  {
    move'mouseeventtype : 0
    up'mouseeventtype : 1
    down'mouseeventtype : 2
  }
  boxshader'stack shader : shader(this = shader(
    vertex'stack string : vertex,
    pixel'stack string : pixel
  ))
  imageshader'stack shader : shader(this = shader(
    vertex'stack string : vertex,
    pixel'stack string : pixel
  ))
  phongcolorshader'stack shader : shader(this = shader(
    vertex'stack string : vertex,
    pixel'stack string : pixel
  ))
  phongtextureshader'stack shader : shader(this = shader(
    vertex'stack string : vertex,
    pixel'stack string : pixel
  ))
  textshader'stack shader : shader(this = shader(
    vertex'stack string : vertex,
    pixel'stack string : pixel
  ))
  --cdefine--
  /* Freetype GL - A C OpenGL Freetype engine
  *
  * Distributed under the OSI-approved BSD 2-Clause License.  See accompanying
  * file `LICENSE` for more details.
  */
  /**
  * Read a fragment or vertex shader from a file
  *
  * @param filename file to read shader from
  * @return         a newly-allocated text buffer containing code. This buffer
  *                 must be freed after usage.
  *
  */
  char *
  shader_read( const char *filename );
  /**
  * Compile a shader from a text buffer.
  *
  * @param source code of the shader
  * @param type   type of the shader
  *
  * @return a handle on the compiled program
  *
  */
  GLuint
  shader_compile( const char* source,
  const GLenum type );
  /**
  * Load a vertex and fragment shader sources and build program
  *
  * @param  vert_filename vertex shader filename
  * @param  frag_filename fragment shader filename
  *
  * @return a handle on the built program
  *
  */
  GLuint
  shader_load( const char * vert_filename,
  const char * frag_filename );    
  --cdefine--
  --cfunction--
  char *repl_str(const char *str, const char *from, const char *to) {
  /* Adjust each of the below values to suit your needs. */
  /* Increment positions cache size initially by this number. */
  size_t cache_sz_inc = 16;
  /* Thereafter, each time capacity needs to be increased,
  * multiply the increment by this factor. */
  const size_t cache_sz_inc_factor = 3;
  /* But never increment capacity by more than this number. */
  const size_t cache_sz_inc_max = 1048576;
  char *pret, *ret = NULL;
  const char *pstr2, *pstr = str;
  size_t i, count = 0;
  #if (__STDC_VERSION__ >= 199901L)
  uintptr_t *pos_cache_tmp, *pos_cache = NULL;
  #else
  ptrdiff_t *pos_cache_tmp, *pos_cache = NULL;
  #endif
  size_t cache_sz = 0;
  size_t cpylen, orglen, retlen, tolen = 0, fromlen = strlen(from);
  /* Find all matches and cache their positions. */
  while ((pstr2 = strstr(pstr, from)) != NULL) {
  count++;
  /* Increase the cache size when necessary. */
  if (cache_sz < count) {
  cache_sz += cache_sz_inc;
  pos_cache_tmp = realloc(pos_cache, sizeof(*pos_cache) * cache_sz);
  if (pos_cache_tmp == NULL) {
  goto end_repl_str;
  } else pos_cache = pos_cache_tmp;
  cache_sz_inc *= cache_sz_inc_factor;
  if (cache_sz_inc > cache_sz_inc_max) {
  cache_sz_inc = cache_sz_inc_max;
  }
  }
  pos_cache[count-1] = pstr2 - str;
  pstr = pstr2 + fromlen;
  }
  orglen = pstr - str + strlen(pstr);
  /* Allocate memory for the post-replacement string. */
  if (count > 0) {
  tolen = strlen(to);
  retlen = orglen + (tolen - fromlen) * count;
  } else  retlen = orglen;
  ret = malloc(retlen + 1);
  if (ret == NULL) {
  goto end_repl_str;
  }
  if (count == 0) {
  /* If no matches, then just duplicate the string. */
  strcpy(ret, str);
  } else {
  /* Otherwise, duplicate the string whilst performing
  * the replacements using the position cache. */
  pret = ret;
  memcpy(pret, str, pos_cache[0]);
  pret += pos_cache[0];
  for (i = 0; i < count; i++) {
  memcpy(pret, to, tolen);
  pret += tolen;
  pstr = str + pos_cache[i] + fromlen;
  cpylen = (i == count-1 ? orglen : pos_cache[i+1]) - pos_cache[i] - fromlen;
  memcpy(pret, pstr, cpylen);
  pret += cpylen;
  }
  ret[retlen] = '\0';
  }
  end_repl_str:
  /* Free the cache and return the post-replacement string,
  * which will be NULL in the event of an error. */
  free(pos_cache);
  return ret;
  }
  // ------------------------------------------------------------ shader_read ---
  char *
  shader_read( const char *filename )
  {
  FILE * file;
  char * buffer;
  size_t size;
  #ifdef WIN32
  errno_t err;
  if( (err  = fopen_s( &file, filename, "rb" )) !=0 ) {
  #else
  file = fopen( filename, "rb" );
  if( !file ) {
  #endif
  fprintf( stderr, "Unable to open file \"%s\".\n", filename );
  return 0;
  }
  fseek( file, 0, SEEK_END );
  size = ftell( file );
  fseek(file, 0, SEEK_SET );
  buffer = (char *) malloc( (size+1) * sizeof( char *) );
  fread( buffer, sizeof(char), size, file );
  buffer[size] = 0;
  fclose( file );
  #ifdef __APPLE__
  char* prev = buffer;
  buffer = repl_str(buffer, "mediump", "");
  free(prev);
  #endif
  return buffer;
  }
  // --------------------------------------------------------- shader_compile ---
  GLuint
  shader_compile( const char* source,
  const GLenum type )
  {
  GLint compile_status;
  GLuint handle = glCreateShader( type );
  glShaderSource( handle, 1, &source, 0 );
  glCompileShader( handle );
  glGetShaderiv( handle, GL_COMPILE_STATUS, &compile_status );
  if( compile_status == GL_FALSE )
  {
  GLchar messages[256];
  glGetShaderInfoLog( handle, sizeof(messages), 0, &messages[0] );
  halt("%s: %s\n", source, messages);
  }
  return handle;
  }
  // ------------------------------------------------------------ shader_load ---
  GLuint
  shader_load( const char * vert_filename,
  const char * frag_filename )
  {
  GLuint handle = glCreateProgram( );
  GLint link_status;
  if( vert_filename && strlen( vert_filename ) )
  {
  char *vert_source = shader_read( vert_filename );
  GLuint vert_shader = shader_compile( vert_source, GL_VERTEX_SHADER);
  glAttachShader( handle, vert_shader);
  glDeleteShader( vert_shader );
  free( vert_source );
  }
  if( frag_filename && strlen( frag_filename ) )
  {
  char *frag_source = shader_read( frag_filename );
  GLuint frag_shader = shader_compile( frag_source, GL_FRAGMENT_SHADER);
  glAttachShader( handle, frag_shader);
  glDeleteShader( frag_shader );
  free( frag_source );
  }
  glLinkProgram( handle );
  glGetProgramiv( handle, GL_LINK_STATUS, &link_status );
  if (link_status == GL_FALSE)
  {
  GLchar messages[256];
  glGetProgramInfoLog( handle, sizeof(messages), 0, &messages[0] );
  halt("%s\n", messages );
  }
  return handle;
  }
  --cfunction--
  style'stack anon2 : anon2(this = anon2())
  {
    left'texthorizontal : 0
    right'texthorizontal : 1
    center'texthorizontal : 2
  }
  {
    top'textvertical : 0
    bottom'textvertical : 1
    center'textvertical : 2
  }
  --cstruct--
  typedef struct {
  float x, y, z;    // position
  float s, t;       // texture
  float r, g, b, a; // color
  } vertex3_texture2_color3_t;	
  --cstruct--
  --cdefine--
  void add_text(vertex_buffer_t * buffer, texture_font_t * font, char *text, vec4 * color, vec2 * pen);	
  vec2 get_text_size(texture_font_t * font, char *text);
  --cdefine--
  --cfunction--
  void add_text(vertex_buffer_t * buffer, texture_font_t * font, char *text, vec4 * color, vec2 * pen) {
  pen->y += (float)(int)font->ascender;
  size_t i;
  float r = color->red, g = color->green, b = color->blue, a = color->alpha;
  for (i = 0; i < strlen(text); ++i) {
  texture_glyph_t *glyph = texture_font_get_glyph( font, text + i );
  if (glyph != NULL) {
  float kerning = 0.0f;
  if( i > 0) {
  kerning = texture_glyph_get_kerning( glyph, text + i - 1 );
  }
  pen->x += kerning;
  float x0 = (float)(int)( pen->x + glyph->offset_x );
  float y0 = (float)(int)( pen->y + glyph->height - glyph->offset_y );
  float x1 = (float)(int)( x0 + glyph->width );
  float y1 = (float)(int)( y0 - glyph->height );
  float s0 = glyph->s0;
  float t0 = glyph->t0;
  float s1 = glyph->s1;
  float t1 = glyph->t1;
  GLuint index = (GLuint)buffer->vertices->size;
  GLuint indices[] = { //
  index, index+1, index+2,
  index, index+2, index+3 };
  vertex3_texture2_color3_t vertices[] = { //
  { x0, y1, 0.0f,  s0,t0,  r,g,b,a },
  { x0, y0, 0.0f,  s0,t1,  r,g,b,a },
  { x1, y0, 0.0f,  s1,t1,  r,g,b,a },
  { x1, y1, 0.0f,  s1,t0,  r,g,b,a } };
  vertex_buffer_push_back_indices( buffer, indices, 6 );
  vertex_buffer_push_back_vertices( buffer, vertices, 4 );
  pen->x += glyph->advance_x;
  }
  }
  }	
  vec2 get_text_size(texture_font_t * font, char *text) {
  vec2 size = {{ 0, font->height }};
  size_t i;
  for( i = 0; i < strlen(text); ++i ) {
  texture_glyph_t *glyph = texture_font_get_glyph(font, text + i);
  if (glyph != NULL) {
  float kerning = 0.0f;
  if( i > 0) {
  kerning = texture_glyph_get_kerning(glyph, text + i - 1);
  }
  size.x += kerning;
  size.x += glyph->advance_x;
  }
  }
  return size;
  }   
  --cfunction--
  --cfunction--
  GLuint png_texture_load(const char * file_name, int * width, int * height)
  {
  // This function was originally written by David Grayson for
  // https://github.com/DavidEGrayson/ahrs-visualizer
  png_byte header[8];
  FILE *fp = fopen(file_name, "rb");
  if (fp == 0)
  {
  perror(file_name);
  return 0;
  }
  // read the header
  fread(header, 1, 8, fp);
  if (png_sig_cmp(header, 0, 8))
  {
  fprintf(stderr, "error: %s is not a PNG.\n", file_name);
  fclose(fp);
  return 0;
  }
  png_structp png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
  if (!png_ptr)
  {
  fprintf(stderr, "error: png_create_read_struct returned 0.\n");
  fclose(fp);
  return 0;
  }
  // create png info struct
  png_infop info_ptr = png_create_info_struct(png_ptr);
  if (!info_ptr)
  {
  fprintf(stderr, "error: png_create_info_struct returned 0.\n");
  png_destroy_read_struct(&png_ptr, (png_infopp)NULL, (png_infopp)NULL);
  fclose(fp);
  return 0;
  }
  // create png info struct
  png_infop end_info = png_create_info_struct(png_ptr);
  if (!end_info)
  {
  fprintf(stderr, "error: png_create_info_struct returned 0.\n");
  png_destroy_read_struct(&png_ptr, &info_ptr, (png_infopp) NULL);
  fclose(fp);
  return 0;
  }
  // the code in this if statement gets called if libpng encounters an error
  if (setjmp(png_jmpbuf(png_ptr))) {
  fprintf(stderr, "error from libpng\n");
  png_destroy_read_struct(&png_ptr, &info_ptr, &end_info);
  fclose(fp);
  return 0;
  }
  // init png reading
  png_init_io(png_ptr, fp);
  // let libpng know you already read the first 8 bytes
  png_set_sig_bytes(png_ptr, 8);
  // read all the info up to the image data
  png_read_info(png_ptr, info_ptr);
  // variables to pass to get info
  int bit_depth, color_type;
  png_uint_32 temp_width, temp_height;
  // get info about png
  png_get_IHDR(png_ptr, info_ptr, &temp_width, &temp_height, &bit_depth, &color_type,
  NULL, NULL, NULL);
  if (width){ *width = temp_width; }
  if (height){ *height = temp_height; }
  //printf("%s: %lux%lu %d\n", file_name, temp_width, temp_height, color_type);
  if (bit_depth != 8)
  {
  fprintf(stderr, "%s: Unsupported bit depth %d.  Must be 8.\n", file_name, bit_depth);
  return 0;
  }
  GLint format;
  switch(color_type)
  {
  case PNG_COLOR_TYPE_RGB:
  format = GL_RGB;
  break;
  case PNG_COLOR_TYPE_RGB_ALPHA:
  format = GL_RGBA;
  break;
  default:
  fprintf(stderr, "%s: Unknown libpng color type %d.\n", file_name, color_type);
  return 0;
  }
  // Update the png info struct.
  png_read_update_info(png_ptr, info_ptr);
  // Row size in bytes.
  int rowbytes = png_get_rowbytes(png_ptr, info_ptr);
  // glTexImage2d requires rows to be 4-byte aligned
  rowbytes += 3 - ((rowbytes-1) % 4);
  // Allocate the image_data as a big block, to be given to opengl
  png_byte * image_data = (png_byte *)malloc(rowbytes * temp_height * sizeof(png_byte)+15);
  if (image_data == NULL)
  {
  fprintf(stderr, "error: could not allocate memory for PNG image data\n");
  png_destroy_read_struct(&png_ptr, &info_ptr, &end_info);
  fclose(fp);
  return 0;
  }
  // row_pointers is for pointing to image_data for reading the png with libpng
  png_byte ** row_pointers = (png_byte **)malloc(temp_height * sizeof(png_byte *));
  if (row_pointers == NULL)
  {
  fprintf(stderr, "error: could not allocate memory for PNG row pointers\n");
  png_destroy_read_struct(&png_ptr, &info_ptr, &end_info);
  free(image_data);
  fclose(fp);
  return 0;
  }
  // set the individual row_pointers to point at the correct offsets of image_data
  for (unsigned int i = 0; i < temp_height; i++)
  {
  row_pointers[temp_height - 1 - i] = image_data + i * rowbytes;
  }
  // read the png into image_data through row_pointers
  png_read_image(png_ptr, row_pointers);
  // Generate the OpenGL texture object
  GLuint texture;
  glGenTextures(1, &texture);
  glBindTexture(GL_TEXTURE_2D, texture);
  glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE );
  glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE );
  glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR );
  glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR );
  glTexImage2D(GL_TEXTURE_2D, 0, format, temp_width, temp_height, 0, format, GL_UNSIGNED_BYTE, image_data);
  // clean up
  png_destroy_read_struct(&png_ptr, &info_ptr, &end_info);
  free(image_data);
  free(row_pointers);
  fclose(fp);
  return texture;
  }
  --cfunction--
  --cstruct--
  /**
  * Tuple of 4 ints.
  *
  * Each field can be addressed using several aliases:
  *  - First component:  <b>x</b>, <b>r</b>, <b>red</b> or <b>vstart</b>
  *  - Second component: <b>y</b>, <b>g</b>, <b>green</b> or <b>vcount</b>
  *  - Third component:  <b>z</b>, <b>b</b>, <b>blue</b>, <b>width</b> or <b>istart</b>
  *  - Fourth component: <b>w</b>, <b>a</b>, <b>alpha</b>, <b>height</b> or <b>icount</b>
  *
  */
  typedef union
  {
  int data[4];    /**< All compoments at once     */
  struct {
  int x;      /**< Alias for first component  */
  int y;      /**< Alias for second component */
  int z;      /**< Alias for third component  */
  int w;      /**< Alias for fourht component */
  };
  struct {
  int x_;     /**< Alias for first component  */
  int y_;     /**< Alias for second component */
  int width;  /**< Alias for third component  */
  int height; /**< Alias for fourth component */
  };
  struct {
  int r;      /**< Alias for first component  */
  int g;      /**< Alias for second component */
  int b;      /**< Alias for third component  */
  int a;      /**< Alias for fourth component */
  };
  struct {
  int red;    /**< Alias for first component  */
  int green;  /**< Alias for second component */
  int blue;   /**< Alias for third component  */
  int alpha;  /**< Alias for fourth component */
  };
  struct {
  int vstart; /**< Alias for first component  */
  int vcount; /**< Alias for second component */
  int istart; /**< Alias for third component  */
  int icount; /**< Alias for fourth component */
  };
  } ivec4;
  /**
  * Tuple of 3 ints.
  *
  * Each field can be addressed using several aliases:
  *  - First component:  <b>x</b>, <b>r</b> or <b>red</b>
  *  - Second component: <b>y</b>, <b>g</b> or <b>green</b>
  *  - Third component:  <b>z</b>, <b>b</b> or <b>blue</b>
  *
  */
  typedef union
  {
  int data[3];    /**< All compoments at once     */
  struct {
  int x;      /**< Alias for first component  */
  int y;      /**< Alias for second component */
  int z;      /**< Alias for third component  */
  };
  struct {
  int r;      /**< Alias for first component  */
  int g;      /**< Alias for second component */
  int b;      /**< Alias for third component  */
  };
  struct {
  int red;    /**< Alias for first component  */
  int green;  /**< Alias for second component */
  int blue;   /**< Alias for third component  */
  };
  } ivec3;
  /**
  * Tuple of 2 ints.
  *
  * Each field can be addressed using several aliases:
  *  - First component: <b>x</b>, <b>s</b> or <b>start</b>
  *  - Second component: <b>y</b>, <b>t</b> or <b>end</b>
  *
  */
  typedef union
  {
  int data[2];    /**< All compoments at once     */
  struct {
  int x;      /**< Alias for first component  */
  int y;      /**< Alias for second component */
  };
  struct {
  int s;      /**< Alias for first component  */
  int t;      /**< Alias for second component */
  };
  struct {
  int start;  /**< Alias for first component  */
  int end;    /**< Alias for second component */
  };
  } ivec2;
  /**
  * Tuple of 4 floats.
  *
  * Each field can be addressed using several aliases:
  *  - First component:  <b>x</b>, <b>left</b>, <b>r</b> or <b>red</b>
  *  - Second component: <b>y</b>, <b>top</b>, <b>g</b> or <b>green</b>
  *  - Third component:  <b>z</b>, <b>width</b>, <b>b</b> or <b>blue</b>
  *  - Fourth component: <b>w</b>, <b>height</b>, <b>a</b> or <b>alpha</b>
  */
  typedef union
  {
  float data[4];    /**< All compoments at once    */
  struct {
  float x;      /**< Alias for first component */
  float y;      /**< Alias for second component */
  float z;      /**< Alias for third component  */
  float w;      /**< Alias for fourth component */
  };
  struct {
  float left;   /**< Alias for first component */
  float top;    /**< Alias for second component */
  float width;  /**< Alias for third component  */
  float height; /**< Alias for fourth component */
  };
  struct {
  float r;      /**< Alias for first component */
  float g;      /**< Alias for second component */
  float b;      /**< Alias for third component  */
  float a;      /**< Alias for fourth component */
  };
  struct {
  float red;    /**< Alias for first component */
  float green;  /**< Alias for second component */
  float blue;   /**< Alias for third component  */
  float alpha;  /**< Alias for fourth component */
  };
  } vec4;
  /**
  * Tuple of 3 floats
  *
  * Each field can be addressed using several aliases:
  *  - First component:  <b>x</b>, <b>r</b> or <b>red</b>
  *  - Second component: <b>y</b>, <b>g</b> or <b>green</b>
  *  - Third component:  <b>z</b>, <b>b</b> or <b>blue</b>
  */
  typedef union
  {
  float data[3];   /**< All compoments at once    */
  struct {
  float x;     /**< Alias for first component */
  float y;     /**< Alias fo second component */
  float z;     /**< Alias fo third component  */
  };
  struct {
  float r;     /**< Alias for first component */
  float g;     /**< Alias fo second component */
  float b;     /**< Alias fo third component  */
  };
  struct {
  float red;   /**< Alias for first component */
  float green; /**< Alias fo second component */
  float blue;  /**< Alias fo third component  */
  };
  } vec3;
  /**
  * Tuple of 2 floats
  *
  * Each field can be addressed using several aliases:
  *  - First component:  <b>x</b> or <b>s</b>
  *  - Second component: <b>y</b> or <b>t</b>
  */
  typedef union
  {
  float data[2]; /**< All components at once     */
  struct {
  float x;   /**< Alias for first component  */
  float y;   /**< Alias for second component */
  };
  struct {
  float s;   /**< Alias for first component  */
  float t;   /**< Alias for second component */
  };
  } vec2;
  /**
  * A texture atlas is used to pack several small regions into a single texture.
  */
  typedef struct texture_atlas_t
  {
  /**
  * Allocated nodes
  */
  vector_t * nodes;
  /**
  *  Width (in pixels) of the underlying texture
  */
  size_t width;
  /**
  * Height (in pixels) of the underlying texture
  */
  size_t height;
  /**
  * Depth (in bytes) of the underlying texture
  */
  size_t depth;
  /**
  * Allocated surface size
  */
  size_t used;
  /**
  * Texture identity (OpenGL)
  */
  unsigned int id;
  /**
  * Atlas data
  */
  unsigned char * data;
  } texture_atlas_t;    
  --cstruct--
  --cdefine--
  /**
  * Creates a new empty texture atlas.
  *
  * @param   width   width of the atlas
  * @param   height  height of the atlas
  * @param   depth   bit depth of the atlas
  * @return          a new empty texture atlas.
  *
  */
  texture_atlas_t *
  texture_atlas_new( const size_t width,
  const size_t height,
  const size_t depth );
  /**
  *  Deletes a texture atlas.
  *
  *  @param self a texture atlas structure
  *
  */
  void
  texture_atlas_delete( texture_atlas_t * self );
  /**
  *  Allocate a new region in the atlas.
  *
  *  @param self   a texture atlas structure
  *  @param width  width of the region to allocate
  *  @param height height of the region to allocate
  *  @return       Coordinates of the allocated region
  *
  */
  ivec4
  texture_atlas_get_region( texture_atlas_t * self,
  const size_t width,
  const size_t height );
  /**
  *  Upload data to the specified atlas region.
  *
  *  @param self   a texture atlas structure
  *  @param x      x coordinate the region
  *  @param y      y coordinate the region
  *  @param width  width of the region
  *  @param height height of the region
  *  @param data   data to be uploaded into the specified region
  *  @param stride stride of the data
  *
  */
  void
  texture_atlas_set_region( texture_atlas_t * self,
  const size_t x,
  const size_t y,
  const size_t width,
  const size_t height,
  const unsigned char *data,
  const size_t stride );
  /**
  *  Remove all allocated regions from the atlas.
  *
  *  @param self   a texture atlas structure
  */
  void
  texture_atlas_clear( texture_atlas_t * self );    
  --cdefine--
  --cfunction--
  // ------------------------------------------------------ texture_atlas_new ---
  texture_atlas_t *
  texture_atlas_new( const size_t width,
  const size_t height,
  const size_t depth )
  {
  texture_atlas_t *self = (texture_atlas_t *) malloc( sizeof(texture_atlas_t) );
  // We want a one pixel border around the whole atlas to avoid any artefact when
  // sampling texture
  ivec3 node = {{1,1,width-2}};
  assert( (depth == 1) || (depth == 3) || (depth == 4) );
  if( self == NULL)
  {
  halt("line %d: No more memory for allocating data\n", __LINE__ );
  }
  self->nodes = vector_new( sizeof(ivec3) );
  self->used = 0;
  self->width = width;
  self->height = height;
  self->depth = depth;
  self->id = 0;
  vector_push_back( self->nodes, &node );
  self->data = (unsigned char *)
  calloc( width*height*depth, sizeof(unsigned char) );
  if( self->data == NULL)
  {
  halt("line %d: No more memory for allocating data\n", __LINE__ );
  }
  return self;
  }
  // --------------------------------------------------- texture_atlas_delete ---
  void
  texture_atlas_delete( texture_atlas_t *self )
  {
  assert( self );
  vector_delete( self->nodes );
  if( self->data )
  {
  free( self->data );
  }
  free( self );
  }
  // ----------------------------------------------- texture_atlas_set_region ---
  void
  texture_atlas_set_region( texture_atlas_t * self,
  const size_t x,
  const size_t y,
  const size_t width,
  const size_t height,
  const unsigned char * data,
  const size_t stride )
  {
  size_t i;
  size_t depth;
  size_t charsize;
  assert( self );
  assert( x > 0);
  assert( y > 0);
  assert( x < (self->width-1));
  assert( (x + width) <= (self->width-1));
  assert( y < (self->height-1));
  assert( (y + height) <= (self->height-1));
  //prevent copying data from undefined position 
  //and prevent memcpy's undefined behavior when count is zero
  assert(height == 0 || (data != NULL && width > 0));
  depth = self->depth;
  charsize = sizeof(char);
  for( i=0; i<height; ++i )
  {
  memcpy( self->data+((y+i)*self->width + x ) * charsize * depth,
  data + (i*stride) * charsize, width * charsize * depth  );
  }
  }
  // ------------------------------------------------------ texture_atlas_fit ---
  int
  texture_atlas_fit( texture_atlas_t * self,
  const size_t index,
  const size_t width,
  const size_t height )
  {
  ivec3 *node;
  int x, y, width_left;
  size_t i;
  assert( self );
  node = (ivec3 *) (vector_get( self->nodes, index ));
  x = node->x;
  y = node->y;
  width_left = width;
  i = index;
  if ( (x + width) > (self->width-1) )
  {
  return -1;
  }
  y = node->y;
  while( width_left > 0 )
  {
  node = (ivec3 *) (vector_get( self->nodes, i ));
  if( node->y > y )
  {
  y = node->y;
  }
  if( (y + height) > (self->height-1) )
  {
  return -1;
  }
  width_left -= node->z;
  ++i;
  }
  return y;
  }
  // ---------------------------------------------------- texture_atlas_merge ---
  void
  texture_atlas_merge( texture_atlas_t * self )
  {
  ivec3 *node, *next;
  size_t i;
  assert( self );
  for( i=0; i< self->nodes->size-1; ++i )
  {
  node = (ivec3 *) (vector_get( self->nodes, i ));
  next = (ivec3 *) (vector_get( self->nodes, i+1 ));
  if( node->y == next->y )
  {
  node->z += next->z;
  vector_erase( self->nodes, i+1 );
  --i;
  }
  }
  }
  // ----------------------------------------------- texture_atlas_get_region ---
  ivec4
  texture_atlas_get_region( texture_atlas_t * self,
  const size_t width,
  const size_t height )
  {
  int y, best_index;
  size_t best_height, best_width;
  ivec3 *node, *prev;
  ivec4 region = {{0,0,width,height}};
  size_t i;
  assert( self );
  best_height = UINT_MAX;
  best_index  = -1;
  best_width = UINT_MAX;
  for( i=0; i<self->nodes->size; ++i )
  {
  y = texture_atlas_fit( self, i, width, height );
  if( y >= 0 )
  {
  node = (ivec3 *) vector_get( self->nodes, i );
  if( ( (y + height) < best_height ) ||
  ( ((y + height) == best_height) && (node->z > 0 && (size_t)node->z < best_width)) )
  {
  best_height = y + height;
  best_index = i;
  best_width = node->z;
  region.x = node->x;
  region.y = y;
  }
  }
  }
  if( best_index == -1 )
  {
  region.x = -1;
  region.y = -1;
  region.width = 0;
  region.height = 0;
  return region;
  }
  node = (ivec3 *) malloc( sizeof(ivec3) );
  if( node == NULL)
  {
  halt("line %d: No more memory for allocating data\n", __LINE__ );
  }
  node->x = region.x;
  node->y = region.y + height;
  node->z = width;
  vector_insert( self->nodes, best_index, node );
  free( node );
  for(i = best_index+1; i < self->nodes->size; ++i)
  {
  node = (ivec3 *) vector_get( self->nodes, i );
  prev = (ivec3 *) vector_get( self->nodes, i-1 );
  if (node->x < (prev->x + prev->z) )
  {
  int shrink = prev->x + prev->z - node->x;
  node->x += shrink;
  node->z -= shrink;
  if (node->z <= 0)
  {
  vector_erase( self->nodes, i );
  --i;
  }
  else
  {
  break;
  }
  }
  else
  {
  break;
  }
  }
  texture_atlas_merge( self );
  self->used += width * height;
  return region;
  }
  // ---------------------------------------------------- texture_atlas_clear ---
  void
  texture_atlas_clear( texture_atlas_t * self )
  {
  ivec3 node = {{1,1,1}};
  assert( self );
  assert( self->data );
  vector_clear( self->nodes );
  self->used = 0;
  // We want a one pixel border around the whole atlas to avoid any artefact when
  // sampling texture
  node.z = self->width-2;
  vector_push_back( self->nodes, &node );
  memset( self->data, 0, self->width*self->height*self->depth );
  }
  --cfunction--
  --cstruct--
  #undef __FTERRORS_H__
  #define FT_ERRORDEF( e, v, s )  { e, s },
  #define FT_ERROR_START_LIST     {
  #define FT_ERROR_END_LIST       { 0, 0 } };
  const struct {
  int          code;
  const char*  message;
  } FT_Errors[] =
  #include FT_ERRORS_H    
  /**
  * A list of possible ways to render a glyph.
  */
  typedef enum rendermode_t
  {
  RENDER_NORMAL,
  RENDER_OUTLINE_EDGE,
  RENDER_OUTLINE_POSITIVE,
  RENDER_OUTLINE_NEGATIVE,
  RENDER_SIGNED_DISTANCE_FIELD
  } rendermode_t;
  /**
  * A structure that hold a kerning value relatively to a Unicode
  * codepoint.
  *
  * This structure cannot be used alone since the (necessary) right
  * Unicode codepoint is implicitely held by the owner of this structure.
  */
  typedef struct kerning_t
  {
  /**
  * Left Unicode codepoint in the kern pair in UTF-32 LE encoding.
  */
  uint32_t codepoint;
  /**
  * Kerning value (in fractional pixels).
  */
  float kerning;
  } kerning_t;
  /*
  * Glyph metrics:
  * --------------
  *
  *                       xmin                     xmax
  *                        |                         |
  *                        |<-------- width -------->|
  *                        |                         |
  *              |         +-------------------------+----------------- ymax
  *              |         |    ggggggggg   ggggg    |     ^        ^
  *              |         |   g:::::::::ggg::::g    |     |        |
  *              |         |  g:::::::::::::::::g    |     |        |
  *              |         | g::::::ggggg::::::gg    |     |        |
  *              |         | g:::::g     g:::::g     |     |        |
  *    offset_x -|-------->| g:::::g     g:::::g     |  offset_y    |
  *              |         | g:::::g     g:::::g     |     |        |
  *              |         | g::::::g    g:::::g     |     |        |
  *              |         | g:::::::ggggg:::::g     |     |        |
  *              |         |  g::::::::::::::::g     |     |      height
  *              |         |   gg::::::::::::::g     |     |        |
  *  baseline ---*---------|---- gggggggg::::::g-----*--------      |
  *            / |         |             g:::::g     |              |
  *     origin   |         | gggggg      g:::::g     |              |
  *              |         | g:::::gg   gg:::::g     |              |
  *              |         |  g::::::ggg:::::::g     |              |
  *              |         |   gg:::::::::::::g      |              |
  *              |         |     ggg::::::ggg        |              |
  *              |         |         gggggg          |              v
  *              |         +-------------------------+----------------- ymin
  *              |                                   |
  *              |------------- advance_x ---------->|
  */
  /**
  * A structure that describe a glyph.
  */
  typedef struct texture_glyph_t
  {
  /**
  * Unicode codepoint this glyph represents in UTF-32 LE encoding.
  */
  uint32_t codepoint;
  /**
  * Glyph's width in pixels.
  */
  size_t width;
  /**
  * Glyph's height in pixels.
  */
  size_t height;
  /**
  * Glyph's left bearing expressed in integer pixels.
  */
  int offset_x;
  /**
  * Glyphs's top bearing expressed in integer pixels.
  *
  * Remember that this is the distance from the baseline to the top-most
  * glyph scanline, upwards y coordinates being positive.
  */
  int offset_y;
  /**
  * For horizontal text layouts, this is the horizontal distance (in
  * fractional pixels) used to increment the pen position when the glyph is
  * drawn as part of a string of text.
  */
  float advance_x;
  /**
  * For vertical text layouts, this is the vertical distance (in fractional
  * pixels) used to increment the pen position when the glyph is drawn as
  * part of a string of text.
  */
  float advance_y;
  /**
  * First normalized texture coordinate (x) of top-left corner
  */
  float s0;
  /**
  * Second normalized texture coordinate (y) of top-left corner
  */
  float t0;
  /**
  * First normalized texture coordinate (x) of bottom-right corner
  */
  float s1;
  /**
  * Second normalized texture coordinate (y) of bottom-right corner
  */
  float t1;
  /**
  * A vector of kerning pairs relative to this glyph.
  */
  vector_t * kerning;
  /**
  * Mode this glyph was rendered
  */
  rendermode_t rendermode;
  /**
  * Glyph outline thickness
  */
  float outline_thickness;
  } texture_glyph_t;
  typedef struct texture_atlas_t texture_atlas_td; 
  /**
  *  Texture font structure.
  */
  typedef struct texture_font_t
  {
  /**
  * Vector of glyphs contained in this font.
  */
  vector_t * glyphs;
  /**
  * Atlas structure to store glyphs data.
  */
  texture_atlas_td * atlas;
  /**
  * font location
  */
  enum {
  TEXTURE_FONT_FILE = 0,
  TEXTURE_FONT_MEMORY,
  } location;
  union {
  /**
  * Font filename, for when location == TEXTURE_FONT_FILE
  */
  char *filename;
  /**
  * Font memory address, for when location == TEXTURE_FONT_MEMORY
  */
  struct {
  const void *base;
  size_t size;
  } memory;
  };
  /**
  * Font size
  */
  float size;
  /**
  * Whether to use autohint when rendering font
  */
  int hinting;
  /**
  * Mode the font is rendering its next glyph
  */
  rendermode_t rendermode;
  /**
  * Outline thickness
  */
  float outline_thickness;
  /**
  * Whether to use our own lcd filter.
  */
  int filtering;
  /**
  * LCD filter weights
  */
  unsigned char lcd_weights[5];
  /**
  * Whether to use kerning if available
  */
  int kerning;
  /**
  * This field is simply used to compute a default line spacing (i.e., the
  * baseline-to-baseline distance) when writing text with this font. Note
  * that it usually is larger than the sum of the ascender and descender
  * taken as absolute values. There is also no guarantee that no glyphs
  * extend above or below subsequent baselines when using this distance.
  */
  float height;
  /**
  * This field is the distance that must be placed between two lines of
  * text. The baseline-to-baseline distance should be computed as:
  * ascender - descender + linegap
  */
  float linegap;
  /**
  * The ascender is the vertical distance from the horizontal baseline to
  * the highest 'character' coordinate in a font face. Unfortunately, font
  * formats define the ascender differently. For some, it represents the
  * ascent of all capital latin characters (without accents), for others it
  * is the ascent of the highest accented character, and finally, other
  * formats define it as being equal to bbox.yMax.
  */
  float ascender;
  /**
  * The descender is the vertical distance from the horizontal baseline to
  * the lowest 'character' coordinate in a font face. Unfortunately, font
  * formats define the descender differently. For some, it represents the
  * descent of all capital latin characters (without accents), for others it
  * is the ascent of the lowest accented character, and finally, other
  * formats define it as being equal to bbox.yMin. This field is negative
  * for values below the baseline.
  */
  float descender;
  /**
  * The position of the underline line for this face. It is the center of
  * the underlining stem. Only relevant for scalable formats.
  */
  float underline_position;
  /**
  * The thickness of the underline for this face. Only relevant for scalable
  * formats.
  */
  float underline_thickness;
  } texture_font_t;
  --cstruct--
  --cdefine--
  /**
  * This function creates a new texture font from given filename and size.  The
  * texture atlas is used to store glyph on demand. Note the depth of the atlas
  * will determine if the font is rendered as alpha channel only (depth = 1) or
  * RGB (depth = 3) that correspond to subpixel rendering (if available on your
  * freetype implementation).
  *
  * @param atlas     A texture atlas
  * @param pt_size   Size of font to be created (in points)
  * @param filename  A font filename
  *
  * @return A new empty font (no glyph inside yet)
  *
  */
  texture_font_t *
  texture_font_new_from_file( texture_atlas_t * atlas,
  const float pt_size,
  const char * filename );
  /**
  * This function creates a new texture font from a memory location and size.
  * The texture atlas is used to store glyph on demand. Note the depth of the
  * atlas will determine if the font is rendered as alpha channel only
  * (depth = 1) or RGB (depth = 3) that correspond to subpixel rendering (if
  * available on your freetype implementation).
  *
  * @param atlas       A texture atlas
  * @param pt_size     Size of font to be created (in points)
  * @param memory_base Start of the font file in memory
  * @param memory_size Size of the font file memory region, in bytes
  *
  * @return A new empty font (no glyph inside yet)
  *
  */
  texture_font_t *
  texture_font_new_from_memory( texture_atlas_t *atlas,
  float pt_size,
  const void *memory_base,
  size_t memory_size );
  /**
  * Delete a texture font. Note that this does not delete the glyph from the
  * texture atlas.
  *
  * @param self a valid texture font
  */
  void
  texture_font_delete( texture_font_t * self );
  /**
  * Request a new glyph from the font. If it has not been created yet, it will
  * be.
  *
  * @param self      A valid texture font
  * @param codepoint Character codepoint to be loaded in UTF-8 encoding.
  *
  * @return A pointer on the new glyph or 0 if the texture atlas is not big
  *         enough
  *
  */
  texture_glyph_t *
  texture_font_get_glyph( texture_font_t * self,
  const char * codepoint );
  /** 
  * Request an already loaded glyph from the font. 
  * 
  * @param self      A valid texture font
  * @param codepoint Character codepoint to be found in UTF-8 encoding.
  *
  * @return A pointer on the glyph or 0 if the glyph is not loaded
  */
  texture_glyph_t *
  texture_font_find_glyph( texture_font_t * self,
  const char * codepoint );
  /**
  * Request the loading of a given glyph.
  *
  * @param self       A valid texture font
  * @param codepoints Character codepoint to be loaded in UTF-8 encoding.
  *
  * @return One if the glyph could be loaded, zero if not.
  */
  int
  texture_font_load_glyph( texture_font_t * self,
  const char * codepoint );
  /**
  * Request the loading of several glyphs at once.
  *
  * @param self       A valid texture font
  * @param codepoints Character codepoints to be loaded in UTF-8 encoding. May
  *                   contain duplicates.
  *
  * @return Number of missed glyph if the texture is not big enough to hold
  *         every glyphs.
  */
  size_t
  texture_font_load_glyphs( texture_font_t * self,
  const char * codepoints );
  /*
  *Increases the size of a fonts texture atlas
  *Invalidates all pointers to font->atlas->data
  *Changes the UV Coordinates of existing glyphs in the font
  *
  *@param self A valid texture font
  *@param width_new Width of the texture atlas after resizing (must be bigger or equal to current width)
  *@param height_new Height of the texture atlas after resizing (must be bigger or equal to current height)
  */
  void
  texture_font_enlarge_atlas( texture_font_t * self, size_t width_new,
  size_t height_new);
  /**
  * Get the kerning between two horizontal glyphs.
  *
  * @param self      A valid texture glyph
  * @param codepoint Character codepoint of the peceding character in UTF-8 encoding.
  *
  * @return x kerning value
  */
  float
  texture_glyph_get_kerning( const texture_glyph_t * self,
  const char * codepoint );
  /**
  * Creates a new empty glyph
  *
  * @return a new empty glyph (not valid)
  */
  texture_glyph_t *
  texture_glyph_new( void );    
  --cdefine--
  --cfunction--
  #define HRES  64
  #define HRESf 64.f
  #define DPI   72
  // ------------------------------------------------- texture_font_load_face ---
  static int
  texture_font_load_face(texture_font_t *self, float size,
  FT_Library *library, FT_Face *face)
  {
  FT_Error error;
  FT_Matrix matrix = { //
  (int)((1.0/HRES) * 0x10000L),
  (int)((0.0)      * 0x10000L),
  (int)((0.0)      * 0x10000L),
  (int)((1.0)      * 0x10000L)};
  assert(library);
  assert(size);
  /* Initialize library */
  error = FT_Init_FreeType(library);
  if(error) {
  fprintf(stderr, "FT_Error (0x%02x) : %s\n",
  FT_Errors[error].code, FT_Errors[error].message);
  goto cleanup;
  }
  /* Load face */
  switch (self->location) {
  case TEXTURE_FONT_FILE:
  error = FT_New_Face(*library, self->filename, 0, face);
  break;
  case TEXTURE_FONT_MEMORY:
  error = FT_New_Memory_Face(*library,
  self->memory.base, self->memory.size, 0, face);
  break;
  }
  if(error) {
  fprintf(stderr, "FT_Error (line %d, code 0x%02x) : %s\n",
  __LINE__, FT_Errors[error].code, FT_Errors[error].message);
  goto cleanup_library;
  }
  /* Select charmap */
  error = FT_Select_Charmap(*face, FT_ENCODING_UNICODE);
  if(error) {
  fprintf(stderr, "FT_Error (line %d, code 0x%02x) : %s\n",
  __LINE__, FT_Errors[error].code, FT_Errors[error].message);
  goto cleanup_face;
  }
  /* Set char size */
  error = FT_Set_Char_Size(*face, (int)(size * HRES), 0, DPI * HRES, DPI);
  if(error) {
  fprintf(stderr, "FT_Error (line %d, code 0x%02x) : %s\n",
  __LINE__, FT_Errors[error].code, FT_Errors[error].message);
  goto cleanup_face;
  }
  /* Set transform matrix */
  FT_Set_Transform(*face, &matrix, NULL);
  return 1;
  cleanup_face:
  FT_Done_Face( *face );
  cleanup_library:
  FT_Done_FreeType( *library );
  cleanup:
  return 0;
  }
  // ------------------------------------------------------ texture_glyph_new ---
  texture_glyph_t *
  texture_glyph_new(void)
  {
  texture_glyph_t *self = (texture_glyph_t *) malloc( sizeof(texture_glyph_t) );
  if(self == NULL) {
  fprintf( stderr,
  "line %d: No more memory for allocating data\n", __LINE__);
  return NULL;
  }
  self->codepoint  = -1;
  self->width     = 0;
  self->height    = 0;
  self->rendermode = RENDER_NORMAL;
  self->outline_thickness = 0.0;
  self->offset_x  = 0;
  self->offset_y  = 0;
  self->advance_x = 0.0;
  self->advance_y = 0.0;
  self->s0        = 0.0;
  self->t0        = 0.0;
  self->s1        = 0.0;
  self->t1        = 0.0;
  self->kerning   = vector_new( sizeof(kerning_t) );
  return self;
  }
  // --------------------------------------------------- texture_glyph_delete ---
  void
  texture_glyph_delete( texture_glyph_t *self )
  {
  assert( self );
  vector_delete( self->kerning );
  free( self );
  }
  // ---------------------------------------------- texture_glyph_get_kerning ---
  float
  texture_glyph_get_kerning( const texture_glyph_t * self,
  const char * codepoint )
  {
  size_t i;
  uint32_t ucodepoint = utf8_to_utf32( codepoint );
  assert( self );
  for( i=0; i<vector_size(self->kerning); ++i )
  {
  kerning_t * kerning = (kerning_t *) vector_get( self->kerning, i );
  if( kerning->codepoint == ucodepoint )
  {
  return kerning->kerning;
  }
  }
  return 0;
  }
  // ------------------------------------------ texture_font_generate_kerning ---
  void
  texture_font_generate_kerning( texture_font_t *self,
  FT_Library *library, FT_Face *face )
  {
  size_t i, j;
  FT_UInt glyph_index, prev_index;
  texture_glyph_t *glyph, *prev_glyph;
  FT_Vector kerning;
  assert( self );
  /* For each glyph couple combination, check if kerning is necessary */
  /* Starts at index 1 since 0 is for the special backgroudn glyph */
  for( i=1; i<self->glyphs->size; ++i )
  {
  glyph = *(texture_glyph_t **) vector_get( self->glyphs, i );
  glyph_index = FT_Get_Char_Index( *face, glyph->codepoint );
  vector_clear( glyph->kerning );
  for( j=1; j<self->glyphs->size; ++j )
  {
  prev_glyph = *(texture_glyph_t **) vector_get( self->glyphs, j );
  prev_index = FT_Get_Char_Index( *face, prev_glyph->codepoint );
  FT_Get_Kerning( *face, prev_index, glyph_index, FT_KERNING_UNFITTED, &kerning );
  // printf("%c(%d)-%c(%d): %ld\n",
  //       prev_glyph->codepoint, prev_glyph->codepoint,
  //       glyph_index, glyph_index, kerning.x);
  if( kerning.x )
  {
  kerning_t k = {prev_glyph->codepoint, kerning.x / (float)(HRESf*HRESf)};
  vector_push_back( glyph->kerning, &k );
  }
  }
  }
  }
  // ------------------------------------------------------ texture_font_init ---
  static int
  texture_font_init(texture_font_t *self)
  {
  FT_Library library;
  FT_Face face;
  FT_Size_Metrics metrics;
  assert(self->atlas);
  assert(self->size > 0);
  assert((self->location == TEXTURE_FONT_FILE && self->filename)
  || (self->location == TEXTURE_FONT_MEMORY
  && self->memory.base && self->memory.size));
  self->glyphs = vector_new(sizeof(texture_glyph_t *));
  self->height = 0;
  self->ascender = 0;
  self->descender = 0;
  self->rendermode = RENDER_NORMAL;
  self->outline_thickness = 0.0;
  self->hinting = 1;
  self->kerning = 1;
  self->filtering = 1;
  // FT_LCD_FILTER_LIGHT   is (0x00, 0x55, 0x56, 0x55, 0x00)
  // FT_LCD_FILTER_DEFAULT is (0x10, 0x40, 0x70, 0x40, 0x10)
  self->lcd_weights[0] = 0x10;
  self->lcd_weights[1] = 0x40;
  self->lcd_weights[2] = 0x70;
  self->lcd_weights[3] = 0x40;
  self->lcd_weights[4] = 0x10;
  if (!texture_font_load_face(self, self->size * 100.f, &library, &face))
  return -1;
  self->underline_position = face->underline_position / (float)(HRESf*HRESf) * self->size;
  self->underline_position = roundf( self->underline_position );
  if( self->underline_position > -2 )
  {
  self->underline_position = -2.0;
  }
  self->underline_thickness = face->underline_thickness / (float)(HRESf*HRESf) * self->size;
  self->underline_thickness = roundf( self->underline_thickness );
  if( self->underline_thickness < 1 )
  {
  self->underline_thickness = 1.0;
  }
  metrics = face->size->metrics;
  self->ascender = (metrics.ascender >> 6) / 100.0f;
  self->descender = (metrics.descender >> 6) / 100.0f;
  self->height = (metrics.height >> 6) / 100.0f;
  self->linegap = self->height - self->ascender + self->descender;
  FT_Done_Face( face );
  FT_Done_FreeType( library );
  /* NULL is a special glyph */
  texture_font_get_glyph( self, NULL );
  return 0;
  }
  // --------------------------------------------- texture_font_new_from_file ---
  texture_font_t *
  texture_font_new_from_file(texture_atlas_t *atlas, const float pt_size,
  const char *filename)
  {
  texture_font_t *self;
  assert(filename);
  self = calloc(1, sizeof(*self));
  if (!self) {
  fprintf(stderr,
  "line %d: No more memory for allocating data\n", __LINE__);
  return NULL;
  }
  self->atlas = atlas;
  self->size  = pt_size;
  self->location = TEXTURE_FONT_FILE;
  self->filename = strdup(filename);
  if (texture_font_init(self)) {
  texture_font_delete(self);
  return NULL;
  }
  return self;
  }
  // ------------------------------------------- texture_font_new_from_memory ---
  texture_font_t *
  texture_font_new_from_memory(texture_atlas_t *atlas, float pt_size,
  const void *memory_base, size_t memory_size)
  {
  texture_font_t *self;
  assert(memory_base);
  assert(memory_size);
  self = calloc(1, sizeof(*self));
  if (!self) {
  fprintf(stderr,
  "line %d: No more memory for allocating data\n", __LINE__);
  return NULL;
  }
  self->atlas = atlas;
  self->size  = pt_size;
  self->location = TEXTURE_FONT_MEMORY;
  self->memory.base = memory_base;
  self->memory.size = memory_size;
  if (texture_font_init(self)) {
  texture_font_delete(self);
  return NULL;
  }
  return self;
  }
  // ---------------------------------------------------- texture_font_delete ---
  void
  texture_font_delete( texture_font_t *self )
  {
  size_t i;
  texture_glyph_t *glyph;
  assert( self );
  if(self->location == TEXTURE_FONT_FILE && self->filename)
  free( self->filename );
  for( i=0; i<vector_size( self->glyphs ); ++i)
  {
  glyph = *(texture_glyph_t **) vector_get( self->glyphs, i );
  texture_glyph_delete( glyph);
  }
  vector_delete( self->glyphs );
  free( self );
  }
  texture_glyph_t *
  texture_font_find_glyph( texture_font_t * self,
  const char * codepoint )
  {
  size_t i;
  texture_glyph_t *glyph;
  uint32_t ucodepoint = utf8_to_utf32( codepoint );
  for( i = 0; i < self->glyphs->size; ++i )
  {
  glyph = *(texture_glyph_t **) vector_get( self->glyphs, i );
  // If codepoint is -1, we don't care about outline type or thickness
  if( (glyph->codepoint == ucodepoint) &&
  ((ucodepoint == -1) ||
  ((glyph->rendermode == self->rendermode) &&
  (glyph->outline_thickness == self->outline_thickness)) ))
  {
  return glyph;
  }
  }
  return NULL;
  }
  // ------------------------------------------------ texture_font_load_glyph ---
  int
  texture_font_load_glyph( texture_font_t * self,
  const char * codepoint )
  {
  size_t i, x, y;
  FT_Library library;
  FT_Error error;
  FT_Face face;
  FT_Glyph ft_glyph = { 0 };
  FT_GlyphSlot slot;
  FT_Bitmap ft_bitmap;
  FT_UInt glyph_index;
  texture_glyph_t *glyph;
  FT_Int32 flags = 0;
  int ft_glyph_top = 0;
  int ft_glyph_left = 0;
  ivec4 region;
  if (!texture_font_load_face(self, self->size, &library, &face))
  return 0;
  /* Check if codepoint has been already loaded */
  if (texture_font_find_glyph(self, codepoint)) {
  FT_Done_Face(face);
  FT_Done_FreeType(library);
  return 1;
  }
  /* codepoint NULL is special : it is used for line drawing (overline,
  * underline, strikethrough) and background.
  */
  if( !codepoint )
  {
  ivec4 region = texture_atlas_get_region( self->atlas, 5, 5 );
  texture_glyph_t * glyph = texture_glyph_new( );
  static unsigned char data[4*4*3] = {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1};
  if ( region.x < 0 )
  {
  fprintf( stderr, "Texture atlas is full (line %d)\n",  __LINE__ );
  FT_Done_Face( face );
  FT_Done_FreeType( library );
  return 0;
  }
  texture_atlas_set_region( self->atlas, region.x, region.y, 4, 4, data, 0 );
  glyph->codepoint = -1;
  glyph->s0 = (region.x+2)/(float)self->atlas->width;
  glyph->t0 = (region.y+2)/(float)self->atlas->height;
  glyph->s1 = (region.x+3)/(float)self->atlas->width;
  glyph->t1 = (region.y+3)/(float)self->atlas->height;
  vector_push_back( self->glyphs, &glyph );
  FT_Done_Face(face);
  FT_Done_FreeType(library);
  return 1;
  }
  flags = 0;
  ft_glyph_top = 0;
  ft_glyph_left = 0;
  glyph_index = FT_Get_Char_Index( face, (FT_ULong)utf8_to_utf32( codepoint ) );
  // WARNING: We use texture-atlas depth to guess if user wants
  //          LCD subpixel rendering
  if( self->rendermode != RENDER_NORMAL && self->rendermode != RENDER_SIGNED_DISTANCE_FIELD )
  {
  flags |= FT_LOAD_NO_BITMAP;
  }
  else
  {
  flags |= FT_LOAD_RENDER;
  }
  if( !self->hinting )
  {
  flags |= FT_LOAD_NO_HINTING | FT_LOAD_NO_AUTOHINT;
  }
  else
  {
  flags |= FT_LOAD_FORCE_AUTOHINT;
  }
  if( self->atlas->depth == 3 )
  {
  FT_Library_SetLcdFilter( library, FT_LCD_FILTER_LIGHT );
  flags |= FT_LOAD_TARGET_LCD;
  if( self->filtering )
  {
  FT_Library_SetLcdFilterWeights( library, self->lcd_weights );
  }
  }
  error = FT_Load_Glyph( face, glyph_index, flags );
  if( error )
  {
  fprintf( stderr, "FT_Error (line %d, code 0x%02x) : %s\n",
  __LINE__, FT_Errors[error].code, FT_Errors[error].message );
  FT_Done_Face( face );
  FT_Done_FreeType( library );
  return 0;
  }
  if( self->rendermode == RENDER_NORMAL || self->rendermode == RENDER_SIGNED_DISTANCE_FIELD )
  {
  slot            = face->glyph;
  ft_bitmap       = slot->bitmap;
  ft_glyph_top    = slot->bitmap_top;
  ft_glyph_left   = slot->bitmap_left;
  }
  else
  {
  FT_Stroker stroker;
  FT_BitmapGlyph ft_bitmap_glyph;
  error = FT_Stroker_New( library, &stroker );
  if( error )
  {
  fprintf(stderr, "FT_Error (0x%02x) : %s\n",
  FT_Errors[error].code, FT_Errors[error].message);
  goto cleanup_stroker;
  }
  FT_Stroker_Set(stroker,
  (int)(self->outline_thickness * HRES),
  FT_STROKER_LINECAP_ROUND,
  FT_STROKER_LINEJOIN_ROUND,
  0);
  error = FT_Get_Glyph( face->glyph, &ft_glyph);
  if( error )
  {
  fprintf(stderr, "FT_Error (0x%02x) : %s\n",
  FT_Errors[error].code, FT_Errors[error].message);
  goto cleanup_stroker;
  }
  if( self->rendermode == RENDER_OUTLINE_EDGE )
  error = FT_Glyph_Stroke( &ft_glyph, stroker, 1 );
  else if ( self->rendermode == RENDER_OUTLINE_POSITIVE )
  error = FT_Glyph_StrokeBorder( &ft_glyph, stroker, 0, 1 );
  else if ( self->rendermode == RENDER_OUTLINE_NEGATIVE )
  error = FT_Glyph_StrokeBorder( &ft_glyph, stroker, 1, 1 );
  if( error )
  {
  fprintf(stderr, "FT_Error (0x%02x) : %s\n",
  FT_Errors[error].code, FT_Errors[error].message);
  goto cleanup_stroker;
  }
  if( self->atlas->depth == 1 )
  error = FT_Glyph_To_Bitmap( &ft_glyph, FT_RENDER_MODE_NORMAL, 0, 1);
  else
  error = FT_Glyph_To_Bitmap( &ft_glyph, FT_RENDER_MODE_LCD, 0, 1);
  if( error )
  {
  fprintf(stderr, "FT_Error (0x%02x) : %s\n",
  FT_Errors[error].code, FT_Errors[error].message);
  goto cleanup_stroker;
  }
  ft_bitmap_glyph = (FT_BitmapGlyph) ft_glyph;
  ft_bitmap       = ft_bitmap_glyph->bitmap;
  ft_glyph_top    = ft_bitmap_glyph->top;
  ft_glyph_left   = ft_bitmap_glyph->left;
  cleanup_stroker:
  FT_Stroker_Done( stroker );
  if( error )
  {
  FT_Done_Face( face );
  FT_Done_FreeType( library );
  return 0;
  }
  }
  struct {
  int left;
  int top;
  int right;
  int bottom;
  } padding = { 0, 0, 1, 1 };
  if( self->rendermode == RENDER_SIGNED_DISTANCE_FIELD )
  {
  padding.top = 1;
  padding.left = 1;
  }
  size_t src_w = ft_bitmap.width/self->atlas->depth;
  size_t src_h = ft_bitmap.rows;
  size_t tgt_w = src_w + padding.left + padding.right;
  size_t tgt_h = src_h + padding.top + padding.bottom;
  region = texture_atlas_get_region( self->atlas, tgt_w, tgt_h );
  if ( region.x < 0 )
  {
  fprintf( stderr, "Texture atlas is full (line %d)\n",  __LINE__ );
  FT_Done_Face( face );
  FT_Done_FreeType( library );
  return 0;
  }
  x = region.x;
  y = region.y;
  unsigned char *buffer = calloc( tgt_w * tgt_h * self->atlas->depth, sizeof(unsigned char) );
  unsigned char *dst_ptr = buffer + (padding.top * tgt_w + padding.left) * self->atlas->depth;
  unsigned char *src_ptr = ft_bitmap.buffer;
  for( i = 0; i < src_h; i++ )
  {
  //difference between width and pitch: https://www.freetype.org/freetype2/docs/reference/ft2-basic_types.html
  memcpy( dst_ptr, src_ptr, ft_bitmap.width);
  dst_ptr += tgt_w * self->atlas->depth;
  src_ptr += ft_bitmap.pitch;
  }
  if( self->rendermode == RENDER_SIGNED_DISTANCE_FIELD )
  {
  unsigned char *sdf = make_distance_mapb( buffer, (unsigned int)tgt_w, (unsigned int)tgt_h );
  free( buffer );
  buffer = sdf;
  }
  texture_atlas_set_region( self->atlas, x, y, tgt_w, tgt_h, buffer, tgt_w * self->atlas->depth);
  free( buffer );
  glyph = texture_glyph_new( );
  glyph->codepoint = utf8_to_utf32( codepoint );
  glyph->width    = tgt_w;
  glyph->height   = tgt_h;
  glyph->rendermode = self->rendermode;
  glyph->outline_thickness = self->outline_thickness;
  glyph->offset_x = ft_glyph_left;
  glyph->offset_y = ft_glyph_top;
  glyph->s0       = x/(float)self->atlas->width;
  glyph->t0       = y/(float)self->atlas->height;
  glyph->s1       = (x + glyph->width)/(float)self->atlas->width;
  glyph->t1       = (y + glyph->height)/(float)self->atlas->height;
  // Discard hinting to get advance
  FT_Load_Glyph( face, glyph_index, FT_LOAD_RENDER | FT_LOAD_NO_HINTING);
  slot = face->glyph;
  glyph->advance_x = slot->advance.x / HRESf;
  glyph->advance_y = slot->advance.y / HRESf;
  vector_push_back( self->glyphs, &glyph );
  if( self->rendermode != RENDER_NORMAL && self->rendermode != RENDER_SIGNED_DISTANCE_FIELD )
  FT_Done_Glyph( ft_glyph );
  texture_font_generate_kerning( self, &library, &face );
  FT_Done_Face( face );
  FT_Done_FreeType( library );
  return 1;
  }
  // ----------------------------------------------- texture_font_load_glyphs ---
  size_t
  texture_font_load_glyphs( texture_font_t * self,
  const char * codepoints )
  {
  size_t i;
  /* Load each glyph */
  for( i = 0; i < strlen(codepoints); i += utf8_surrogate_len(codepoints + i) ) {
  if( !texture_font_load_glyph( self, codepoints + i ) )
  return utf8_strlen( codepoints + i );
  }
  return 0;
  }
  // ------------------------------------------------- texture_font_get_glyph ---
  texture_glyph_t *
  texture_font_get_glyph( texture_font_t * self,
  const char * codepoint )
  {
  texture_glyph_t *glyph;
  assert( self );
  assert( self->filename );
  assert( self->atlas );
  /* Check if codepoint has been already loaded */
  if( (glyph = texture_font_find_glyph( self, codepoint )) )
  return glyph;
  /* Glyph has not been already loaded */
  if( texture_font_load_glyph( self, codepoint ) )
  return texture_font_find_glyph( self, codepoint );
  return NULL;
  }
  // ------------------------------------------------- texture_font_enlarge_atlas ---
  void
  texture_font_enlarge_atlas( texture_font_t * self, size_t width_new,
  size_t height_new)
  {
  assert(self);
  assert(self->atlas);
  //ensure size increased
  assert(width_new >= self->atlas->width);
  assert(height_new >= self->atlas->height);
  assert(width_new + height_new > self->atlas->width + self->atlas->height);
  texture_atlas_t* ta = self->atlas;
  size_t width_old = ta->width;
  size_t height_old = ta->height;
  //allocate new buffer
  unsigned char* data_old = ta->data;
  ta->data = calloc(1,width_new*height_new * sizeof(char)*ta->depth);
  //update atlas size
  ta->width = width_new;
  ta->height = height_new;
  //add node reflecting the gained space on the right
  if(width_new>width_old){
  ivec3 node;
  node.x = width_old - 1;
  node.y = 1;
  node.z = width_new - width_old;
  vector_push_back(ta->nodes, &node);
  }
  //copy over data from the old buffer, skipping first row and column because of the margin
  size_t pixel_size = sizeof(char) * ta->depth;
  size_t old_row_size = width_old * pixel_size;
  texture_atlas_set_region(ta, 1, 1, width_old - 2, height_old - 2, data_old + old_row_size + pixel_size, old_row_size);
  free(data_old);
  //change uv coordinates of existing glyphs to reflect size change
  float mulw = (float)width_old / width_new;
  float mulh = (float)height_old / height_new;
  size_t i;
  for (i = 0; i < vector_size(self->glyphs); i++) {
  texture_glyph_t* g = *(texture_glyph_t**)vector_get(self->glyphs, i);
  g->s0 *= mulw;
  g->s1 *= mulw;
  g->t0 *= mulh;
  g->t1 *= mulh;
  }
  }
  --cfunction--
  --cdefine--
  /**
  * Returns the size in bytes of a given UTF-8 encoded character surrogate
  *
  * @param character  An UTF-8 encoded character
  *
  * @return  The length of the surrogate in bytes.
  */
  size_t
  utf8_surrogate_len( const char* character );
  /**
  * Return the length of the given UTF-8 encoded and
  * NULL terminated string.
  *
  * @param string  An UTF-8 encoded string
  *
  * @return  The length of the string in characters.
  */
  size_t
  utf8_strlen( const char* string );
  /**
  * Converts a given UTF-8 encoded character to its UTF-32 LE equivalent
  *
  * @param character  An UTF-8 encoded character
  *
  * @return  The equivalent of the given character in UTF-32 LE
  *          encoding.
  */
  uint32_t
  utf8_to_utf32( const char * character );
  --cdefine--
  --cfunction--
  // ----------------------------------------------------- utf8_surrogate_len ---
  size_t
  utf8_surrogate_len( const char* character )
  {
  size_t result = 0;
  char test_char;
  if (!character)
  return 0;
  test_char = character[0];
  if ((test_char & 0x80) == 0)
  return 1;
  while (test_char & 0x80)
  {
  test_char <<= 1;
  result++;
  }
  return result;
  }
  // ------------------------------------------------------------ utf8_strlen ---
  size_t
  utf8_strlen( const char* string )
  {
  const char* ptr = string;
  size_t result = 0;
  while (*ptr)
  {
  ptr += utf8_surrogate_len(ptr);
  result++;
  }
  return result;
  }
  uint32_t
  utf8_to_utf32( const char * character )
  {
  uint32_t result = -1;
  if( !character )
  {
  return result;
  }
  if( ( character[0] & 0x80 ) == 0x0 )
  {
  result = character[0];
  }
  if( ( character[0] & 0xC0 ) == 0xC0 )
  {
  result = ( ( character[0] & 0x3F ) << 6 ) | ( character[1] & 0x3F );
  }
  if( ( character[0] & 0xE0 ) == 0xE0 )
  {
  result = ( ( character[0] & 0x1F ) << ( 6 + 6 ) ) | ( ( character[1] & 0x3F ) << 6 ) | ( character[2] & 0x3F );
  }
  if( ( character[0] & 0xF0 ) == 0xF0 )
  {
  result = ( ( character[0] & 0x0F ) << ( 6 + 6 + 6 ) ) | ( ( character[1] & 0x3F ) << ( 6 + 6 ) ) | ( ( character[2] & 0x3F ) << 6 ) | ( character[3] & 0x3F );
  }
  if( ( character[0] & 0xF8 ) == 0xF8 )
  {
  result = ( ( character[0] & 0x07 ) << ( 6 + 6 + 6 + 6 ) ) | ( ( character[1] & 0x3F ) << ( 6 + 6 + 6 ) ) | ( ( character[2] & 0x3F ) << ( 6 + 6 ) ) | ( ( character[3] & 0x3F ) << 6 ) | ( character[4] & 0x3F );
  }
  return result;
  }
  --cfunction--
  --ctypedef--
  typedef struct vector_td vector_t;
  --ctypedef--
  --cstruct--
  /**
  *  Generic vector structure.
  *
  * @memberof vector
  */
  struct vector_td
  {
  /** Pointer to dynamically allocated items. */
  void * items;
  /** Number of items that can be held in currently allocated storage. */
  size_t capacity;
  /** Number of items. */
  size_t size;
  /** Size (in bytes) of a single item. */
  size_t item_size;
  };
  --cstruct--
  --cdefine--
  /**
  * @file   vector.h
  * @author Nicolas Rougier (Nicolas.Rougier@inria.fr)
  *
  * @defgroup vector Vector
  *
  * The vector structure and accompanying functions loosely mimic the STL C++
  * vector class. It is used by @ref texture-atlas (for storing nodes), @ref
  * texture-font (for storing glyphs) and @ref font-manager (for storing fonts).
  * More information at http://www.cppreference.com/wiki/container/vector/start
  */
  /**
  * Creates a new empty vector.
  *
  * @param   item_size    item size in bytes
  * @return               a new empty vector
  *
  */
  vector_t *
  vector_new( size_t item_size );
  /**
  *  Deletes a vector.
  *
  *  @param self a vector structure
  *
  */
  void
  vector_delete( vector_t *self );
  /**
  *  Returns a pointer to the item located at specified index.
  *
  *  @param  self  a vector structure
  *  @param  index the index of the item to be returned
  *  @return       pointer on the specified item
  */
  const void *
  vector_get( const vector_t *self,
  size_t index );
  /**
  *  Returns a pointer to the first item.
  *
  *  @param  self  a vector structure
  *  @return       pointer on the first item
  */
  const void *
  vector_front( const vector_t *self );
  /**
  *  Returns a pointer to the last item
  *
  *  @param  self  a vector structure
  *  @return pointer on the last item
  */
  const void *
  vector_back( const vector_t *self );
  /**
  *  Check if an item is contained within the vector.
  *
  *  @param  self  a vector structure
  *  @param  item  item to be searched in the vector
  *  @param  cmp   a pointer a comparison function
  *  @return       1 if item is contained within the vector, 0 otherwise
  */
  int
  vector_contains( const vector_t *self,
  const void *item,
  int (*cmp)(const void *, const void *) );
  /**
  *  Checks whether the vector is empty.
  *
  *  @param  self  a vector structure
  *  @return       1 if the vector is empty, 0 otherwise
  */
  int
  vector_empty( const vector_t *self );
  /**
  *  Returns the number of items
  *
  *  @param  self  a vector structure
  *  @return       number of items
  */
  size_t
  vector_size( const vector_t *self );
  /**
  *  Reserve storage such that it can hold at last size items.
  *
  *  @param  self  a vector structure
  *  @param  size  the new storage capacity
  */
  void
  vector_reserve( vector_t *self,
  const size_t size );
  /**
  *  Returns current storage capacity
  *
  *  @param  self  a vector structure
  *  @return       storage capacity
  */
  size_t
  vector_capacity( const vector_t *self );
  /**
  *  Decrease capacity to fit actual size.
  *
  *  @param  self  a vector structure
  */
  void
  vector_shrink( vector_t *self );
  /**
  *  Removes all items.
  *
  *  @param  self  a vector structure
  */
  void
  vector_clear( vector_t *self );
  /**
  *  Replace an item.
  *
  *  @param  self  a vector structure
  *  @param  index the index of the item to be replaced
  *  @param  item  the new item
  */
  void
  vector_set( vector_t *self,
  const size_t index,
  const void *item );
  /**
  *  Erase an item.
  *
  *  @param  self  a vector structure
  *  @param  index the index of the item to be erased
  */
  void
  vector_erase( vector_t *self,
  const size_t index );
  /**
  *  Erase a range of items.
  *
  *  @param  self  a vector structure
  *  @param  first the index of the first item to be erased
  *  @param  last  the index of the last item to be erased
  */
  void
  vector_erase_range( vector_t *self,
  const size_t first,
  const size_t last );
  /**
  *  Appends given item to the end of the vector.
  *
  *  @param  self a vector structure
  *  @param  item the item to be inserted
  */
  void
  vector_push_back( vector_t *self,
  const void *item );
  /**
  *  Removes the last item of the vector.
  *
  *  @param  self a vector structure
  */
  void
  vector_pop_back( vector_t *self );
  /**
  *  Resizes the vector to contain size items
  *
  *  If the current size is less than size, additional items are appended and
  *  initialized with value. If the current size is greater than size, the
  *  vector is reduced to its first size elements.
  *
  *  @param  self a vector structure
  *  @param  size the new size
  */
  void
  vector_resize( vector_t *self,
  const size_t size );
  /**
  *  Insert a single item at specified index.
  *
  *  @param  self  a vector structure
  *  @param  index location before which to insert item
  *  @param  item  the item to be inserted
  */
  void
  vector_insert( vector_t *self,
  const size_t index,
  const void *item );
  /**
  *  Insert raw data at specified index.
  *
  *  @param  self  a vector structure
  *  @param  index location before which to insert item
  *  @param  data  a pointer to the items to be inserted
  *  @param  count the number of items to be inserted
  */
  void
  vector_insert_data( vector_t *self,
  const size_t index,
  const void * data,
  const size_t count );
  /**
  *  Append raw data to the end of the vector.
  *
  *  @param  self  a vector structure
  *  @param  data  a pointer to the items to be inserted
  *  @param  count the number of items to be inserted
  */
  void
  vector_push_back_data( vector_t *self,
  const void * data,
  const size_t count );
  /**
  *  Sort vector items according to cmp function.
  *
  *  @param  self  a vector structure
  *  @param  cmp   a pointer a comparison function
  */
  void
  vector_sort( vector_t *self,
  int (*cmp)(const void *, const void *) );    
  --cdefine--
  --cfunction--
  // ------------------------------------------------------------- vector_new ---
  vector_t *
  vector_new( size_t item_size )
  {
  vector_t *self = (vector_t *) malloc( sizeof(vector_t) );
  assert( item_size );
  if( !self )
  {
  halt("line %d: No more memory for allocating data\n", __LINE__ );
  }
  self->item_size = item_size;
  self->size      = 0;
  self->capacity  = 1;
  self->items     = malloc( self->item_size * self->capacity );
  return self;
  }
  // ---------------------------------------------------------- vector_delete ---
  void
  vector_delete( vector_t *self )
  {
  assert( self );
  free( self->items );
  free( self );
  }
  // ------------------------------------------------------------- vector_get ---
  const void *
  vector_get( const vector_t *self,
  size_t index )
  {
  assert( self );
  assert( self->size );
  assert( index  < self->size );
  return (char*)(self->items) + index * self->item_size;
  }
  // ----------------------------------------------------------- vector_front ---
  const void *
  vector_front( const vector_t *self )
  {
  assert( self );
  assert( self->size );
  return vector_get( self, 0 );
  }
  // ------------------------------------------------------------ vector_back ---
  const void *
  vector_back( const vector_t *self )
  {
  assert( self );
  assert( self->size );
  return vector_get( self, self->size-1 );
  }
  // -------------------------------------------------------- vector_contains ---
  int
  vector_contains( const vector_t *self,
  const void *item,
  int (*cmp)(const void *, const void *) )
  {
  size_t i;
  assert( self );
  for( i=0; i<self->size; ++i )
  {
  if( (*cmp)(item, vector_get(self,i) ) == 0 )
  {
  return 1;
  }
  }
  return 0;
  }
  // ----------------------------------------------------------- vector_empty ---
  int
  vector_empty( const vector_t *self )
  {
  assert( self );
  return self->size == 0;
  }
  // ------------------------------------------------------------ vector_size ---
  size_t
  vector_size( const vector_t *self )
  {
  assert( self );
  return self->size;
  }
  // --------------------------------------------------------- vector_reserve ---
  void
  vector_reserve( vector_t *self,
  const size_t size )
  {
  assert( self );
  if( self->capacity < size)
  {
  self->items = realloc( self->items, size * self->item_size );
  self->capacity = size;
  }
  }
  // -------------------------------------------------------- vector_capacity ---
  size_t
  vector_capacity( const vector_t *self )
  {
  assert( self );
  return self->capacity;
  }
  // ---------------------------------------------------------- vector_shrink ---
  void
  vector_shrink( vector_t *self )
  {
  assert( self );
  if( self->capacity > self->size )
  {
  self->items = realloc( self->items, self->size * self->item_size );
  }
  self->capacity = self->size;
  }
  // ----------------------------------------------------------- vector_clear ---
  void
  vector_clear( vector_t *self )
  {
  assert( self );
  self->size = 0;
  }
  // ------------------------------------------------------------- vector_set ---
  void
  vector_set( vector_t *self,
  const size_t index,
  const void *item )
  {
  assert( self );
  assert( self->size );
  assert( index  < self->size );
  memcpy( (char *)(self->items) + index * self->item_size,
  item, self->item_size );
  }
  // ---------------------------------------------------------- vector_insert ---
  void
  vector_insert( vector_t *self,
  const size_t index,
  const void *item )
  {
  assert( self );
  assert( index <= self->size);
  if( self->capacity <= self->size )
  {
  vector_reserve(self, 2 * self->capacity );
  }
  if( index < self->size )
  {
  memmove( (char *)(self->items) + (index + 1) * self->item_size,
  (char *)(self->items) + (index + 0) * self->item_size,
  (self->size - index)  * self->item_size);
  }
  self->size++;
  vector_set( self, index, item );
  }
  // ----------------------------------------------------- vector_erase_range ---
  void
  vector_erase_range( vector_t *self,
  const size_t first,
  const size_t last )
  {
  assert( self );
  assert( first < self->size );
  assert( last  < self->size+1 );
  assert( first < last );
  memmove( (char *)(self->items) + first * self->item_size,
  (char *)(self->items) + last  * self->item_size,
  (self->size - last)   * self->item_size);
  self->size -= (last-first);
  }
  // ----------------------------------------------------------- vector_erase ---
  void
  vector_erase( vector_t *self,
  const size_t index )
  {
  assert( self );
  assert( index < self->size );
  vector_erase_range( self, index, index+1 );
  }
  // ------------------------------------------------------- vector_push_back ---
  void
  vector_push_back( vector_t *self,
  const void *item )
  {
  vector_insert( self, self->size, item );
  }
  // -------------------------------------------------------- vector_pop_back ---
  void
  vector_pop_back( vector_t *self )
  {
  assert( self );
  assert( self->size );
  self->size--;
  }
  // ---------------------------------------------------------- vector_resize ---
  void
  vector_resize( vector_t *self,
  const size_t size )
  {
  assert( self );
  if( size > self->capacity)
  {
  vector_reserve( self, size );
  self->size = self->capacity;
  }
  else
  {
  self->size = size;
  }
  }
  // -------------------------------------------------- vector_push_back_data ---
  void
  vector_push_back_data( vector_t *self,
  const void * data,
  const size_t count )
  {
  assert( self );
  assert( data );
  assert( count );
  if( self->capacity < (self->size+count) )
  {
  vector_reserve(self, self->size+count);
  }
  memmove( (char *)(self->items) + self->size * self->item_size, data,
  count*self->item_size );
  self->size += count;
  }
  // ----------------------------------------------------- vector_insert_data ---
  void
  vector_insert_data( vector_t *self,
  const size_t index,
  const void * data,
  const size_t count )
  {
  assert( self );
  assert( index < self->size );
  assert( data );
  assert( count );
  if( self->capacity < (self->size+count) )
  {
  vector_reserve(self, self->size+count);
  }
  memmove( (char *)(self->items) + (index + count ) * self->item_size,
  (char *)(self->items) + (index ) * self->item_size,
  count*self->item_size );
  memmove( (char *)(self->items) + index * self->item_size, data,
  count*self->item_size );
  self->size += count;
  }
  // ------------------------------------------------------------ vector_sort ---
  void
  vector_sort( vector_t *self,
  int (*cmp)(const void *, const void *) )
  {
  assert( self );
  assert( self->size );
  qsort(self->items, self->size, self->item_size, cmp);
  }
  --cfunction--
  --cinclude--
  /**
  * Maximum number of attributes per vertex
  *
  * @private
  */
  #define MAX_VERTEX_ATTRIBUTE 16    
  --cinclude--
  --ctypedef--
  typedef struct vertex_attribute_td vertex_attribute_t;
  --ctypedef--
  --cstruct--
  /**
  *  Generic vertex attribute.
  */
  struct vertex_attribute_td
  {
  /**
  *  atribute name
  */
  GLchar * name;
  /**
  * index of the generic vertex attribute to be modified.
  */
  GLuint index;
  /**
  * Number of components per generic vertex attribute.
  *
  * Must be 1, 2, 3, or 4. The initial value is 4.
  */
  GLint size;
  /**
  *  data type of each component in the array.
  *
  *  Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT,
  *  GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, or GL_DOUBLE are
  *  accepted. The initial value is GL_FLOAT.
  */
  GLenum type;
  /**
  *  whether fixed-point data values should be normalized (GL_TRUE) or
  *  converted directly as fixed-point values (GL_FALSE) when they are
  *  accessed.
  */
  GLboolean normalized;
  /**
  *  byte offset between consecutive generic vertex attributes.
  *
  *  If stride is 0, the generic vertex attributes are understood to be
  *  tightly packed in the array. The initial value is 0.
  */
  GLsizei stride;
  /**
  *  pointer to the first component of the first attribute element in the
  *  array.
  */
  GLvoid * pointer;
  /**
  * pointer to the function that enable this attribute.
  */
  void ( * enable )(void *);
  };
  --cstruct--
  --cdefine--
  /**
  * Create an attribute from the given parameters.
  *
  * @param size       number of component
  * @param type       data type
  * @param normalized Whether fixed-point data values should be normalized
  (GL_TRUE) or converted directly as fixed-point values
  (GL_FALSE) when they are  accessed.
  * @param stride     byte offset between consecutive attributes.
  * @param pointer    pointer to the first component of the first attribute
  *                   element in the array.
  * @return           a new initialized vertex attribute.
  *
  * @private
  */
  vertex_attribute_t *
  vertex_attribute_new( GLchar * name,
  GLint size,
  GLenum type,
  GLboolean normalized,
  GLsizei stride,
  GLvoid *pointer );
  /**
  * Delete a vertex attribute.
  *
  * @param  self a vertex attribute
  *
  */
  void
  vertex_attribute_delete( vertex_attribute_t * self );
  /**
  * Create an attribute from the given description.
  *
  * @param  format Format string specifies the format of a vertex attribute.
  * @return        an initialized vertex attribute
  *
  * @private
  */
  vertex_attribute_t *
  vertex_attribute_parse( char *format );
  /**
  * Enable a vertex attribute.
  *
  * @param attr  a vertex attribute
  *
  * @private
  */
  void
  vertex_attribute_enable( vertex_attribute_t *attr );    
  --cdefine--
  --cfunction--
  // ----------------------------------------------------------------------------
  vertex_attribute_t *
  vertex_attribute_new( GLchar * name,
  GLint size,
  GLenum type,
  GLboolean normalized,
  GLsizei stride,
  GLvoid *pointer )
  {
  vertex_attribute_t *attribute =
  (vertex_attribute_t *) malloc (sizeof(vertex_attribute_t));
  assert( size > 0 );
  attribute->name       = (GLchar *) strdup( name );
  attribute->index      = -1;
  attribute->size       = size;
  attribute->type       = type;
  attribute->normalized = normalized;
  attribute->stride     = stride;
  attribute->pointer    = pointer;
  return attribute;
  }
  // ----------------------------------------------------------------------------
  void
  vertex_attribute_delete( vertex_attribute_t * self )
  {
  assert( self );
  free( self->name );
  free( self );
  }
  // ----------------------------------------------------------------------------
  vertex_attribute_t *
  vertex_attribute_parse( char *format )
  {
  GLenum type = 0;
  int size;
  int normalized = 0;
  char ctype;
  char *name;
  vertex_attribute_t *attr;
  char *p = strchr(format, ':');
  if( p != NULL)
  {
  name = strndup(format, p-format);
  if( *(++p) == '\0' )
  {
  fprintf( stderr, "No size specified for '%s' attribute\n", name );
  free( name );
  return 0;
  }
  size = *p - '0';
  if( *(++p) == '\0' )
  {
  fprintf( stderr, "No format specified for '%s' attribute\n", name );
  free( name );
  return 0;
  }
  ctype = *p;
  if( *(++p) != '\0' )
  {
  if( *p == 'n' )
  {
  normalized = 1;
  }
  }
  }
  else
  {
  fprintf(stderr, "Vertex attribute format not understood ('%s')\n", format );
  return 0;
  }
  switch( ctype )
  {
  case 'b': type = GL_BYTE;           break;
  case 'B': type = GL_UNSIGNED_BYTE;  break;
  case 's': type = GL_SHORT;          break;
  case 'S': type = GL_UNSIGNED_SHORT; break;
  case 'i': type = GL_INT;            break;
  case 'I': type = GL_UNSIGNED_INT;   break;
  case 'f': type = GL_FLOAT;          break;
  default:  type = 0;                 break;
  }
  attr = vertex_attribute_new( name, size, type, normalized, 0, 0 );
  free( name );
  return attr;
  }
  // ----------------------------------------------------------------------------
  void
  vertex_attribute_enable( vertex_attribute_t *attr )
  {
  if( attr->index == -1 )
  {
  GLint program;
  glGetIntegerv( GL_CURRENT_PROGRAM, &program );
  if( program == 0)
  {
  return;
  }
  attr->index = glGetAttribLocation( program, attr->name );
  if( attr->index == -1 )
  {
  return;
  }
  }
  glEnableVertexAttribArray( attr->index );
  glVertexAttribPointer( attr->index, attr->size, attr->type,
  attr->normalized, attr->stride, attr->pointer );
  }
  --cfunction--
  --ctypedef--
  typedef struct vertex_buffer_td vertex_buffer_t;
  --ctypedef--
  --cstruct--
  /**
  * Generic vertex buffer.
  */
  struct vertex_buffer_td
  {
  /** Format of the vertex buffer. */
  char * format;
  /** Vector of vertices. */
  vector_t * vertices;
  #ifdef FREETYPE_GL_USE_VAO
  /** GL identity of the Vertex Array Object */
  GLuint VAO_id;
  #endif
  /** GL identity of the vertices buffer. */
  GLuint vertices_id;
  /** Vector of indices. */
  vector_t * indices;
  /** GL identity of the indices buffer. */
  GLuint indices_id;
  /** Current size of the vertices buffer in GPU */
  size_t GPU_vsize;
  /** Current size of the indices buffer in GPU*/
  size_t GPU_isize;
  /** GL primitives to render. */
  GLenum mode;
  /** Whether the vertex buffer needs to be uploaded to GPU memory. */
  char state;
  /** Individual items */
  vector_t * items;
  /** Array of attributes. */
  vertex_attribute_t *attributes[MAX_VERTEX_ATTRIBUTE];
  };
  --cstruct--
  --cdefine--
  #ifdef WIN32
  // strndup() is not available on Windows
  char *strndup( const char *s1, size_t n);
  #endif
  /**
  * Creates an empty vertex buffer.
  *
  * @param  format a string describing vertex format.
  * @return        an empty vertex buffer.
  */
  vertex_buffer_t *
  vertex_buffer_new( const char *format );
  /**
  * Deletes vertex buffer and releases GPU memory.
  *
  * @param  self  a vertex buffer
  */
  void
  vertex_buffer_delete( vertex_buffer_t * self );
  /**
  *  Returns the number of items in the vertex buffer
  *
  *  @param  self  a vertex buffer
  *  @return       number of items
  */
  size_t
  vertex_buffer_size( const vertex_buffer_t *self );
  /**
  *  Returns vertex format
  *
  *  @param  self  a vertex buffer
  *  @return       vertex format
  */
  const char *
  vertex_buffer_format( const vertex_buffer_t *self );
  /**
  * Print information about a vertex buffer
  *
  * @param  self  a vertex buffer
  */
  void
  vertex_buffer_print( vertex_buffer_t * self );
  /**
  * Prepare vertex buffer for render.
  *
  * @param  self  a vertex buffer
  * @param  mode  render mode
  */
  void
  vertex_buffer_render_setup ( vertex_buffer_t *self,
  GLenum mode );
  /**
  * Finish rendering by setting back modified states
  *
  * @param  self  a vertex buffer
  */
  void
  vertex_buffer_render_finish ( vertex_buffer_t *self );
  /**
  * Render vertex buffer.
  *
  * @param  self  a vertex buffer
  * @param  mode  render mode
  */
  void
  vertex_buffer_render ( vertex_buffer_t *self,
  GLenum mode );
  /**
  * Render a specified item from the vertex buffer.
  *
  * @param  self   a vertex buffer
  * @param  index index of the item to be rendered
  */
  void
  vertex_buffer_render_item ( vertex_buffer_t *self,
  size_t index );
  /**
  * Upload buffer to GPU memory.
  *
  * @param  self  a vertex buffer
  */
  void
  vertex_buffer_upload( vertex_buffer_t *self );
  /**
  * Clear all items.
  *
  * @param  self  a vertex buffer
  */
  void
  vertex_buffer_clear( vertex_buffer_t *self );
  /**
  * Appends indices at the end of the buffer.
  *
  * @param  self     a vertex buffer
  * @param  indices  indices to be appended
  * @param  icount   number of indices to be appended
  *
  * @private
  */
  void
  vertex_buffer_push_back_indices ( vertex_buffer_t *self,
  const GLuint * indices,
  const size_t icount );
  /**
  * Appends vertices at the end of the buffer.
  *
  * @note Internal use
  *
  * @param  self     a vertex buffer
  * @param  vertices vertices to be appended
  * @param  vcount   number of vertices to be appended
  *
  * @private
  */
  void
  vertex_buffer_push_back_vertices ( vertex_buffer_t *self,
  const void * vertices,
  const size_t vcount );
  /**
  * Insert indices in the buffer.
  *
  * @param  self    a vertex buffer
  * @param  index   location before which to insert indices
  * @param  indices indices to be appended
  * @param  icount  number of indices to be appended
  *
  * @private
  */
  void
  vertex_buffer_insert_indices ( vertex_buffer_t *self,
  const size_t index,
  const GLuint *indices,
  const size_t icount );
  /**
  * Insert vertices in the buffer.
  *
  * @param  self     a vertex buffer
  * @param  index    location before which to insert vertices
  * @param  vertices vertices to be appended
  * @param  vcount   number of vertices to be appended
  *
  * @private
  */
  void
  vertex_buffer_insert_vertices ( vertex_buffer_t *self,
  const size_t index,
  const void *vertices,
  const size_t vcount );
  /**
  * Erase indices in the buffer.
  *
  * @param  self   a vertex buffer
  * @param  first  the index of the first index to be erased
  * @param  last   the index of the last index to be erased
  *
  * @private
  */
  void
  vertex_buffer_erase_indices ( vertex_buffer_t *self,
  const size_t first,
  const size_t last );
  /**
  * Erase vertices in the buffer.
  *
  * @param  self   a vertex buffer
  * @param  first  the index of the first vertex to be erased
  * @param  last   the index of the last vertex to be erased
  *
  * @private
  */
  void
  vertex_buffer_erase_vertices ( vertex_buffer_t *self,
  const size_t first,
  const size_t last );
  /**
  * Append a new item to the collection.
  *
  * @param  self   a vertex buffer
  * @param  vcount   number of vertices
  * @param  vertices raw vertices data
  * @param  icount   number of indices
  * @param  indices  raw indices data
  */
  size_t
  vertex_buffer_push_back( vertex_buffer_t * self,
  const void * vertices, const size_t vcount,
  const GLuint * indices, const size_t icount );
  /**
  * Insert a new item into the vertex buffer.
  *
  * @param  self      a vertex buffer
  * @param  index     location before which to insert item
  * @param  vertices  raw vertices data
  * @param  vcount    number of vertices
  * @param  indices   raw indices data
  * @param  icount    number of indices
  */
  size_t
  vertex_buffer_insert( vertex_buffer_t * self,
  const size_t index,
  const void * vertices, const size_t vcount,
  const GLuint * indices, const size_t icount );
  /**
  * Erase an item from the vertex buffer.
  *
  * @param  self     a vertex buffer
  * @param  index    index of the item to be deleted
  */
  void
  vertex_buffer_erase( vertex_buffer_t * self,
  const size_t index );    
  --cdefine--
  --cfunction--
  #ifdef WIN32
  // strndup() is not available on Windows
  char *strndup( const char *s1, size_t n)
  {
  char *copy= (char*)malloc( n+1 );
  memcpy( copy, s1, n );
  copy[n] = 0;
  return copy;
  };
  #endif
  /**
  * Buffer status
  */
  #define CLEAN  (0)
  #define DIRTY  (1)
  #define FROZEN (2)
  // ----------------------------------------------------------------------------
  vertex_buffer_t *
  vertex_buffer_new( const char *format )
  {
  size_t i, index = 0, stride = 0;
  const char *start = 0, *end = 0;
  GLchar *pointer = 0;
  vertex_buffer_t *self = (vertex_buffer_t *) malloc (sizeof(vertex_buffer_t));
  if( !self )
  {
  return NULL;
  }
  self->format = strdup( format );
  for( i=0; i<MAX_VERTEX_ATTRIBUTE; ++i )
  {
  self->attributes[i] = 0;
  }
  start = format;
  do
  {
  char *desc = 0;
  vertex_attribute_t *attribute;
  GLuint attribute_size = 0;
  end = (char *) (strchr(start+1, ','));
  if (end == NULL)
  {
  desc = strdup( start );
  }
  else
  {
  desc = strndup( start, end-start );
  }
  attribute = vertex_attribute_parse( desc );
  start = end+1;
  free(desc);
  attribute->pointer = pointer;
  switch( attribute->type )
  {
  case GL_BOOL:           attribute_size = sizeof(GLboolean); break;
  case GL_BYTE:           attribute_size = sizeof(GLbyte); break;
  case GL_UNSIGNED_BYTE:  attribute_size = sizeof(GLubyte); break;
  case GL_SHORT:          attribute_size = sizeof(GLshort); break;
  case GL_UNSIGNED_SHORT: attribute_size = sizeof(GLushort); break;
  case GL_INT:            attribute_size = sizeof(GLint); break;
  case GL_UNSIGNED_INT:   attribute_size = sizeof(GLuint); break;
  case GL_FLOAT:          attribute_size = sizeof(GLfloat); break;
  default:                attribute_size = 0;
  }
  stride  += attribute->size*attribute_size;
  pointer += attribute->size*attribute_size;
  self->attributes[index] = attribute;
  index++;
  } while ( end && (index < MAX_VERTEX_ATTRIBUTE) );
  for( i=0; i<index; ++i )
  {
  self->attributes[i]->stride = stride;
  }
  #ifdef FREETYPE_GL_USE_VAO
  self->VAO_id = 0;
  #endif
  self->vertices = vector_new( stride );
  self->vertices_id  = 0;
  self->GPU_vsize = 0;
  self->indices = vector_new( sizeof(GLuint) );
  self->indices_id  = 0;
  self->GPU_isize = 0;
  self->items = vector_new( sizeof(ivec4) );
  self->state = DIRTY;
  self->mode = GL_TRIANGLES;
  return self;
  }
  // ----------------------------------------------------------------------------
  void
  vertex_buffer_delete( vertex_buffer_t *self )
  {
  size_t i;
  assert( self );
  for( i=0; i<MAX_VERTEX_ATTRIBUTE; ++i )
  {
  if( self->attributes[i] )
  {
  vertex_attribute_delete( self->attributes[i] );
  }
  }
  #ifdef FREETYPE_GL_USE_VAO
  if( self->VAO_id )
  {
  glDeleteVertexArrays( 1, &self->VAO_id );
  }
  self->VAO_id = 0;
  #endif
  vector_delete( self->vertices );
  self->vertices = 0;
  if( self->vertices_id )
  {
  glDeleteBuffers( 1, &self->vertices_id );
  }
  self->vertices_id = 0;
  vector_delete( self->indices );
  self->indices = 0;
  if( self->indices_id )
  {
  glDeleteBuffers( 1, &self->indices_id );
  }
  self->indices_id = 0;
  vector_delete( self->items );
  if( self->format )
  {
  free( self->format );
  }
  self->format = 0;
  self->state = 0;
  free( self );
  }
  // ----------------------------------------------------------------------------
  const char *
  vertex_buffer_format( const vertex_buffer_t *self )
  {
  assert( self );
  return self->format;
  }
  // ----------------------------------------------------------------------------
  size_t
  vertex_buffer_size( const vertex_buffer_t *self )
  {
  assert( self );
  return vector_size( self->items );
  }
  // ----------------------------------------------------------------------------
  void
  vertex_buffer_print( vertex_buffer_t * self )
  {
  int i = 0;
  static char *gltypes[9] = {
  "GL_BOOL",
  "GL_BYTE",
  "GL_UNSIGNED_BYTE",
  "GL_SHORT",
  "GL_UNSIGNED_SHORT",
  "GL_INT",
  "GL_UNSIGNED_INT",
  "GL_FLOAT",
  "GL_VOID"
  };
  assert(self);
  fprintf( stderr, "%zu vertices, %zu indices\n",
  vector_size( self->vertices ), vector_size( self->indices ) );
  while( self->attributes[i] )
  {
  int j = 8;
  switch( self->attributes[i]->type )
  {
  case GL_BOOL:           j=0; break;
  case GL_BYTE:           j=1; break;
  case GL_UNSIGNED_BYTE:  j=2; break;
  case GL_SHORT:          j=3; break;
  case GL_UNSIGNED_SHORT: j=4; break;
  case GL_INT:            j=5; break;
  case GL_UNSIGNED_INT:   j=6; break;
  case GL_FLOAT:          j=7; break;
  default:                j=8; break;
  }
  fprintf(stderr, "%s : %dx%s (+%p)\n",
  self->attributes[i]->name,
  self->attributes[i]->size,
  gltypes[j],
  self->attributes[i]->pointer);
  i += 1;
  }
  }
  // ----------------------------------------------------------------------------
  void
  vertex_buffer_upload ( vertex_buffer_t *self )
  {
  size_t vsize, isize;
  if( self->state == FROZEN )
  {
  return;
  }
  if( !self->vertices_id )
  {
  glGenBuffers( 1, &self->vertices_id );
  }
  if( !self->indices_id )
  {
  glGenBuffers( 1, &self->indices_id );
  }
  vsize = self->vertices->size*self->vertices->item_size;
  isize = self->indices->size*self->indices->item_size;
  // Always upload vertices first such that indices do not point to non
  // existing data (if we get interrupted in between for example).
  // Upload vertices
  glBindBuffer( GL_ARRAY_BUFFER, self->vertices_id );
  if( vsize != self->GPU_vsize )
  {
  glBufferData( GL_ARRAY_BUFFER,
  vsize, self->vertices->items, GL_DYNAMIC_DRAW );
  self->GPU_vsize = vsize;
  }
  else
  {
  glBufferSubData( GL_ARRAY_BUFFER,
  0, vsize, self->vertices->items );
  }
  glBindBuffer( GL_ARRAY_BUFFER, 0 );
  // Upload indices
  glBindBuffer( GL_ELEMENT_ARRAY_BUFFER, self->indices_id );
  if( isize != self->GPU_isize )
  {
  glBufferData( GL_ELEMENT_ARRAY_BUFFER,
  isize, self->indices->items, GL_DYNAMIC_DRAW );
  self->GPU_isize = isize;
  }
  else
  {
  glBufferSubData( GL_ELEMENT_ARRAY_BUFFER,
  0, isize, self->indices->items );
  }
  glBindBuffer( GL_ELEMENT_ARRAY_BUFFER, 0 );
  }
  // ----------------------------------------------------------------------------
  void
  vertex_buffer_clear( vertex_buffer_t *self )
  {
  assert( self );
  self->state = FROZEN;
  vector_clear( self->indices );
  vector_clear( self->vertices );
  vector_clear( self->items );
  self->state = DIRTY;
  }
  // ----------------------------------------------------------------------------
  void
  vertex_buffer_render_setup ( vertex_buffer_t *self, GLenum mode )
  {
  size_t i;
  #ifdef FREETYPE_GL_USE_VAO
  // Unbind so no existing VAO-state is overwritten,
  // (e.g. the GL_ELEMENT_ARRAY_BUFFER-binding).
  glBindVertexArray( 0 );
  #endif
  if( self->state != CLEAN )
  {
  vertex_buffer_upload( self );
  self->state = CLEAN;
  }
  #ifdef FREETYPE_GL_USE_VAO
  if( self->VAO_id == 0 )
  {
  // Generate and set up VAO
  glGenVertexArrays( 1, &self->VAO_id );
  glBindVertexArray( self->VAO_id );
  glBindBuffer( GL_ARRAY_BUFFER, self->vertices_id );
  for( i=0; i<MAX_VERTEX_ATTRIBUTE; ++i )
  {
  vertex_attribute_t *attribute = self->attributes[i];
  if( attribute == 0 )
  {
  continue;
  }
  else
  {
  vertex_attribute_enable( attribute );
  }
  }
  glBindBuffer( GL_ARRAY_BUFFER, 0 );
  if( self->indices->size )
  {
  glBindBuffer( GL_ELEMENT_ARRAY_BUFFER, self->indices_id );
  }
  }
  // Bind VAO for drawing
  glBindVertexArray( self->VAO_id );
  #else
  glBindBuffer( GL_ARRAY_BUFFER, self->vertices_id );
  for( i=0; i<MAX_VERTEX_ATTRIBUTE; ++i )
  {
  vertex_attribute_t *attribute = self->attributes[i];
  if ( attribute == 0 )
  {
  continue;
  }
  else
  {
  vertex_attribute_enable( attribute );
  }
  }
  if( self->indices->size )
  {
  glBindBuffer( GL_ELEMENT_ARRAY_BUFFER, self->indices_id );
  }
  #endif
  self->mode = mode;
  }
  // ----------------------------------------------------------------------------
  void
  vertex_buffer_render_finish ( vertex_buffer_t *self )
  {
  #ifdef FREETYPE_GL_USE_VAO
  glBindVertexArray( 0 );
  #else
  int i;
  for( i=0; i<MAX_VERTEX_ATTRIBUTE; ++i )
  {
  vertex_attribute_t *attribute = self->attributes[i];
  if( attribute == 0 )
  {
  continue;
  }
  else
  {
  glDisableVertexAttribArray( attribute->index );
  }
  }
  glBindBuffer( GL_ARRAY_BUFFER, 0 );
  glBindBuffer( GL_ELEMENT_ARRAY_BUFFER, 0 );
  #endif
  }
  // ----------------------------------------------------------------------------
  void
  vertex_buffer_render_item ( vertex_buffer_t *self,
  size_t index )
  {
  ivec4 * item = (ivec4 *) vector_get( self->items, index );
  assert( self );
  assert( index < vector_size( self->items ) );
  if( self->indices->size )
  {
  size_t start = item->istart;
  size_t count = item->icount;
  glDrawElements( self->mode, count, GL_UNSIGNED_INT, (void *)(start*sizeof(GLuint)) );
  }
  else if( self->vertices->size )
  {
  size_t start = item->vstart;
  size_t count = item->vcount;
  glDrawArrays( self->mode, start*self->vertices->item_size, count);
  }
  }
  // ----------------------------------------------------------------------------
  void
  vertex_buffer_render ( vertex_buffer_t *self, GLenum mode )
  {
  size_t vcount = self->vertices->size;
  size_t icount = self->indices->size;
  vertex_buffer_render_setup( self, mode );
  if( icount )
  {
  glDrawElements( mode, icount, GL_UNSIGNED_INT, 0 );
  }
  else
  {
  glDrawArrays( mode, 0, vcount );
  }
  vertex_buffer_render_finish( self );
  }
  // ----------------------------------------------------------------------------
  void
  vertex_buffer_push_back_indices ( vertex_buffer_t * self,
  const GLuint * indices,
  const size_t icount )
  {
  assert( self );
  self->state |= DIRTY;
  vector_push_back_data( self->indices, indices, icount );
  }
  // ----------------------------------------------------------------------------
  void
  vertex_buffer_push_back_vertices ( vertex_buffer_t * self,
  const void * vertices,
  const size_t vcount )
  {
  assert( self );
  self->state |= DIRTY;
  vector_push_back_data( self->vertices, vertices, vcount );
  }
  // ----------------------------------------------------------------------------
  void
  vertex_buffer_insert_indices ( vertex_buffer_t *self,
  const size_t index,
  const GLuint *indices,
  const size_t count )
  {
  assert( self );
  assert( self->indices );
  assert( index < self->indices->size+1 );
  self->state |= DIRTY;
  vector_insert_data( self->indices, index, indices, count );
  }
  // ----------------------------------------------------------------------------
  void
  vertex_buffer_insert_vertices( vertex_buffer_t *self,
  const size_t index,
  const void *vertices,
  const size_t vcount )
  {
  size_t i;
  assert( self );
  assert( self->vertices );
  assert( index < self->vertices->size+1 );
  self->state |= DIRTY;
  for( i=0; i<self->indices->size; ++i )
  {
  if( *(GLuint *)(vector_get( self->indices, i )) > index )
  {
  *(GLuint *)(vector_get( self->indices, i )) += index;
  }
  }
  vector_insert_data( self->vertices, index, vertices, vcount );
  }
  // ----------------------------------------------------------------------------
  void
  vertex_buffer_erase_indices( vertex_buffer_t *self,
  const size_t first,
  const size_t last )
  {
  assert( self );
  assert( self->indices );
  assert( first < self->indices->size );
  assert( (last) <= self->indices->size );
  self->state |= DIRTY;
  vector_erase_range( self->indices, first, last );
  }
  // ----------------------------------------------------------------------------
  void
  vertex_buffer_erase_vertices( vertex_buffer_t *self,
  const size_t first,
  const size_t last )
  {
  size_t i;
  assert( self );
  assert( self->vertices );
  assert( first < self->vertices->size );
  assert( last <= self->vertices->size );
  assert( last > first );
  self->state |= DIRTY;
  for( i=0; i<self->indices->size; ++i )
  {
  if( *(GLuint *)(vector_get( self->indices, i )) > first )
  {
  *(GLuint *)(vector_get( self->indices, i )) -= (last-first);
  }
  }
  vector_erase_range( self->vertices, first, last );
  }
  // ----------------------------------------------------------------------------
  size_t
  vertex_buffer_push_back( vertex_buffer_t * self,
  const void * vertices, const size_t vcount,
  const GLuint * indices, const size_t icount )
  {
  return vertex_buffer_insert( self, vector_size( self->items ),
  vertices, vcount, indices, icount );
  }
  // ----------------------------------------------------------------------------
  size_t
  vertex_buffer_insert( vertex_buffer_t * self, const size_t index,
  const void * vertices, const size_t vcount,
  const GLuint * indices, const size_t icount )
  {
  size_t vstart, istart, i;
  ivec4 item;
  assert( self );
  assert( vertices );
  assert( indices );
  self->state = FROZEN;
  // Push back vertices
  vstart = vector_size( self->vertices );
  vertex_buffer_push_back_vertices( self, vertices, vcount );
  // Push back indices
  istart = vector_size( self->indices );
  vertex_buffer_push_back_indices( self, indices, icount );
  // Update indices within the vertex buffer
  for( i=0; i<icount; ++i )
  {
  *(GLuint *)(vector_get( self->indices, istart+i )) += vstart;
  }
  // Insert item
  item.x = vstart;
  item.y = vcount;
  item.z = istart;
  item.w = icount;
  vector_insert( self->items, index, &item );
  self->state = DIRTY;
  return index;
  }
  // ----------------------------------------------------------------------------
  void
  vertex_buffer_erase( vertex_buffer_t * self,
  const size_t index )
  {
  ivec4 * item;
  int vstart;
  size_t vcount, istart, icount, i;
  assert( self );
  assert( index < vector_size( self->items ) );
  item = (ivec4 *) vector_get( self->items, index );
  vstart = item->vstart;
  vcount = item->vcount;
  istart = item->istart;
  icount = item->icount;
  // Update items
  for( i=0; i<vector_size(self->items); ++i )
  {
  ivec4 * item = (ivec4 *) vector_get( self->items, i );
  if( item->vstart > vstart)
  {
  item->vstart -= vcount;
  item->istart -= icount;
  }
  }
  self->state = FROZEN;
  vertex_buffer_erase_indices( self, istart, istart+icount );
  vertex_buffer_erase_vertices( self, vstart, vstart+vcount );
  vector_erase( self->items, index );
  self->state = DIRTY;
  }
  --cfunction--
  vertex_location_texture_normal_format'stack string : string(this = string(
    count'i32 = count,
    data'stack array!char = data
  ))
  --cfunction--
  #include <lib/ui/obj_parser.c>
  --cfunction--
  saturateshader'stack shader : shader(this = shader(
    vertex'stack string : vertex,
    pixel'stack string : pixel
  ))
  root'heap #element : heap gridlayout(this = gridlayout(
    children'stack array!#element : children,
    margin'stack margin = margin,
    cols'stack array!gridunit = cols,
    rows'stack array!gridunit = rows,
    _rect'stack rect = _rect
  )) as heap #element
  runloop()
  void
}

